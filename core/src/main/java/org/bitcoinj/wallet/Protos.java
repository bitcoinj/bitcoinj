// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wallet.proto

package org.bitcoinj.wallet;

public final class Protos {
  private Protos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface PeerAddressOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.PeerAddress)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required bytes ip_address = 1;</code>
     * @return Whether the ipAddress field is set.
     */
    boolean hasIpAddress();
    /**
     * <code>required bytes ip_address = 1;</code>
     * @return The ipAddress.
     */
    com.google.protobuf.ByteString getIpAddress();

    /**
     * <code>required uint32 port = 2;</code>
     * @return Whether the port field is set.
     */
    boolean hasPort();
    /**
     * <code>required uint32 port = 2;</code>
     * @return The port.
     */
    int getPort();

    /**
     * <code>required uint64 services = 3;</code>
     * @return Whether the services field is set.
     */
    boolean hasServices();
    /**
     * <code>required uint64 services = 3;</code>
     * @return The services.
     */
    long getServices();
  }
  /**
   * Protobuf type {@code wallet.PeerAddress}
   */
  public  static final class PeerAddress extends
      com.google.protobuf.GeneratedMessageLite<
          PeerAddress, PeerAddress.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.PeerAddress)
      PeerAddressOrBuilder {
    private PeerAddress() {
      ipAddress_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int IP_ADDRESS_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString ipAddress_;
    /**
     * <code>required bytes ip_address = 1;</code>
     * @return Whether the ipAddress field is set.
     */
    @java.lang.Override
    public boolean hasIpAddress() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required bytes ip_address = 1;</code>
     * @return The ipAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getIpAddress() {
      return ipAddress_;
    }
    /**
     * <code>required bytes ip_address = 1;</code>
     * @param value The ipAddress to set.
     */
    private void setIpAddress(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      ipAddress_ = value;
    }
    /**
     * <code>required bytes ip_address = 1;</code>
     */
    private void clearIpAddress() {
      bitField0_ = (bitField0_ & ~0x00000001);
      ipAddress_ = getDefaultInstance().getIpAddress();
    }

    public static final int PORT_FIELD_NUMBER = 2;
    private int port_;
    /**
     * <code>required uint32 port = 2;</code>
     * @return Whether the port field is set.
     */
    @java.lang.Override
    public boolean hasPort() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>required uint32 port = 2;</code>
     * @return The port.
     */
    @java.lang.Override
    public int getPort() {
      return port_;
    }
    /**
     * <code>required uint32 port = 2;</code>
     * @param value The port to set.
     */
    private void setPort(int value) {
      bitField0_ |= 0x00000002;
      port_ = value;
    }
    /**
     * <code>required uint32 port = 2;</code>
     */
    private void clearPort() {
      bitField0_ = (bitField0_ & ~0x00000002);
      port_ = 0;
    }

    public static final int SERVICES_FIELD_NUMBER = 3;
    private long services_;
    /**
     * <code>required uint64 services = 3;</code>
     * @return Whether the services field is set.
     */
    @java.lang.Override
    public boolean hasServices() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>required uint64 services = 3;</code>
     * @return The services.
     */
    @java.lang.Override
    public long getServices() {
      return services_;
    }
    /**
     * <code>required uint64 services = 3;</code>
     * @param value The services to set.
     */
    private void setServices(long value) {
      bitField0_ |= 0x00000004;
      services_ = value;
    }
    /**
     * <code>required uint64 services = 3;</code>
     */
    private void clearServices() {
      bitField0_ = (bitField0_ & ~0x00000004);
      services_ = 0L;
    }

    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.PeerAddress parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.PeerAddress prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code wallet.PeerAddress}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.PeerAddress, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.PeerAddress)
        org.bitcoinj.wallet.Protos.PeerAddressOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.PeerAddress.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required bytes ip_address = 1;</code>
       * @return Whether the ipAddress field is set.
       */
      @java.lang.Override
      public boolean hasIpAddress() {
        return instance.hasIpAddress();
      }
      /**
       * <code>required bytes ip_address = 1;</code>
       * @return The ipAddress.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getIpAddress() {
        return instance.getIpAddress();
      }
      /**
       * <code>required bytes ip_address = 1;</code>
       * @param value The ipAddress to set.
       * @return This builder for chaining.
       */
      public Builder setIpAddress(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIpAddress(value);
        return this;
      }
      /**
       * <code>required bytes ip_address = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIpAddress() {
        copyOnWrite();
        instance.clearIpAddress();
        return this;
      }

      /**
       * <code>required uint32 port = 2;</code>
       * @return Whether the port field is set.
       */
      @java.lang.Override
      public boolean hasPort() {
        return instance.hasPort();
      }
      /**
       * <code>required uint32 port = 2;</code>
       * @return The port.
       */
      @java.lang.Override
      public int getPort() {
        return instance.getPort();
      }
      /**
       * <code>required uint32 port = 2;</code>
       * @param value The port to set.
       * @return This builder for chaining.
       */
      public Builder setPort(int value) {
        copyOnWrite();
        instance.setPort(value);
        return this;
      }
      /**
       * <code>required uint32 port = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPort() {
        copyOnWrite();
        instance.clearPort();
        return this;
      }

      /**
       * <code>required uint64 services = 3;</code>
       * @return Whether the services field is set.
       */
      @java.lang.Override
      public boolean hasServices() {
        return instance.hasServices();
      }
      /**
       * <code>required uint64 services = 3;</code>
       * @return The services.
       */
      @java.lang.Override
      public long getServices() {
        return instance.getServices();
      }
      /**
       * <code>required uint64 services = 3;</code>
       * @param value The services to set.
       * @return This builder for chaining.
       */
      public Builder setServices(long value) {
        copyOnWrite();
        instance.setServices(value);
        return this;
      }
      /**
       * <code>required uint64 services = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearServices() {
        copyOnWrite();
        instance.clearServices();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.PeerAddress)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.PeerAddress();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "ipAddress_",
              "port_",
              "services_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0003\u0001\u150a\u0000\u0002" +
                "\u150b\u0001\u0003\u1503\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.PeerAddress> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.PeerAddress.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.PeerAddress>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.PeerAddress)
    private static final org.bitcoinj.wallet.Protos.PeerAddress DEFAULT_INSTANCE;
    static {
      PeerAddress defaultInstance = new PeerAddress();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PeerAddress.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.PeerAddress getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PeerAddress> PARSER;

    public static com.google.protobuf.Parser<PeerAddress> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EncryptedDataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.EncryptedData)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The initialisation vector for the AES encryption (16 bytes)
     * </pre>
     *
     * <code>required bytes initialisation_vector = 1;</code>
     * @return Whether the initialisationVector field is set.
     */
    boolean hasInitialisationVector();
    /**
     * <pre>
     * The initialisation vector for the AES encryption (16 bytes)
     * </pre>
     *
     * <code>required bytes initialisation_vector = 1;</code>
     * @return The initialisationVector.
     */
    com.google.protobuf.ByteString getInitialisationVector();

    /**
     * <pre>
     * The encrypted private key
     * </pre>
     *
     * <code>required bytes encrypted_private_key = 2;</code>
     * @return Whether the encryptedPrivateKey field is set.
     */
    boolean hasEncryptedPrivateKey();
    /**
     * <pre>
     * The encrypted private key
     * </pre>
     *
     * <code>required bytes encrypted_private_key = 2;</code>
     * @return The encryptedPrivateKey.
     */
    com.google.protobuf.ByteString getEncryptedPrivateKey();
  }
  /**
   * Protobuf type {@code wallet.EncryptedData}
   */
  public  static final class EncryptedData extends
      com.google.protobuf.GeneratedMessageLite<
          EncryptedData, EncryptedData.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.EncryptedData)
      EncryptedDataOrBuilder {
    private EncryptedData() {
      initialisationVector_ = com.google.protobuf.ByteString.EMPTY;
      encryptedPrivateKey_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int INITIALISATION_VECTOR_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString initialisationVector_;
    /**
     * <pre>
     * The initialisation vector for the AES encryption (16 bytes)
     * </pre>
     *
     * <code>required bytes initialisation_vector = 1;</code>
     * @return Whether the initialisationVector field is set.
     */
    @java.lang.Override
    public boolean hasInitialisationVector() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The initialisation vector for the AES encryption (16 bytes)
     * </pre>
     *
     * <code>required bytes initialisation_vector = 1;</code>
     * @return The initialisationVector.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getInitialisationVector() {
      return initialisationVector_;
    }
    /**
     * <pre>
     * The initialisation vector for the AES encryption (16 bytes)
     * </pre>
     *
     * <code>required bytes initialisation_vector = 1;</code>
     * @param value The initialisationVector to set.
     */
    private void setInitialisationVector(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      initialisationVector_ = value;
    }
    /**
     * <pre>
     * The initialisation vector for the AES encryption (16 bytes)
     * </pre>
     *
     * <code>required bytes initialisation_vector = 1;</code>
     */
    private void clearInitialisationVector() {
      bitField0_ = (bitField0_ & ~0x00000001);
      initialisationVector_ = getDefaultInstance().getInitialisationVector();
    }

    public static final int ENCRYPTED_PRIVATE_KEY_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString encryptedPrivateKey_;
    /**
     * <pre>
     * The encrypted private key
     * </pre>
     *
     * <code>required bytes encrypted_private_key = 2;</code>
     * @return Whether the encryptedPrivateKey field is set.
     */
    @java.lang.Override
    public boolean hasEncryptedPrivateKey() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The encrypted private key
     * </pre>
     *
     * <code>required bytes encrypted_private_key = 2;</code>
     * @return The encryptedPrivateKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getEncryptedPrivateKey() {
      return encryptedPrivateKey_;
    }
    /**
     * <pre>
     * The encrypted private key
     * </pre>
     *
     * <code>required bytes encrypted_private_key = 2;</code>
     * @param value The encryptedPrivateKey to set.
     */
    private void setEncryptedPrivateKey(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      encryptedPrivateKey_ = value;
    }
    /**
     * <pre>
     * The encrypted private key
     * </pre>
     *
     * <code>required bytes encrypted_private_key = 2;</code>
     */
    private void clearEncryptedPrivateKey() {
      bitField0_ = (bitField0_ & ~0x00000002);
      encryptedPrivateKey_ = getDefaultInstance().getEncryptedPrivateKey();
    }

    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.EncryptedData prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code wallet.EncryptedData}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.EncryptedData, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.EncryptedData)
        org.bitcoinj.wallet.Protos.EncryptedDataOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.EncryptedData.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The initialisation vector for the AES encryption (16 bytes)
       * </pre>
       *
       * <code>required bytes initialisation_vector = 1;</code>
       * @return Whether the initialisationVector field is set.
       */
      @java.lang.Override
      public boolean hasInitialisationVector() {
        return instance.hasInitialisationVector();
      }
      /**
       * <pre>
       * The initialisation vector for the AES encryption (16 bytes)
       * </pre>
       *
       * <code>required bytes initialisation_vector = 1;</code>
       * @return The initialisationVector.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getInitialisationVector() {
        return instance.getInitialisationVector();
      }
      /**
       * <pre>
       * The initialisation vector for the AES encryption (16 bytes)
       * </pre>
       *
       * <code>required bytes initialisation_vector = 1;</code>
       * @param value The initialisationVector to set.
       * @return This builder for chaining.
       */
      public Builder setInitialisationVector(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setInitialisationVector(value);
        return this;
      }
      /**
       * <pre>
       * The initialisation vector for the AES encryption (16 bytes)
       * </pre>
       *
       * <code>required bytes initialisation_vector = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearInitialisationVector() {
        copyOnWrite();
        instance.clearInitialisationVector();
        return this;
      }

      /**
       * <pre>
       * The encrypted private key
       * </pre>
       *
       * <code>required bytes encrypted_private_key = 2;</code>
       * @return Whether the encryptedPrivateKey field is set.
       */
      @java.lang.Override
      public boolean hasEncryptedPrivateKey() {
        return instance.hasEncryptedPrivateKey();
      }
      /**
       * <pre>
       * The encrypted private key
       * </pre>
       *
       * <code>required bytes encrypted_private_key = 2;</code>
       * @return The encryptedPrivateKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getEncryptedPrivateKey() {
        return instance.getEncryptedPrivateKey();
      }
      /**
       * <pre>
       * The encrypted private key
       * </pre>
       *
       * <code>required bytes encrypted_private_key = 2;</code>
       * @param value The encryptedPrivateKey to set.
       * @return This builder for chaining.
       */
      public Builder setEncryptedPrivateKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setEncryptedPrivateKey(value);
        return this;
      }
      /**
       * <pre>
       * The encrypted private key
       * </pre>
       *
       * <code>required bytes encrypted_private_key = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearEncryptedPrivateKey() {
        copyOnWrite();
        instance.clearEncryptedPrivateKey();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.EncryptedData)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.EncryptedData();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "initialisationVector_",
              "encryptedPrivateKey_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0002\u0001\u150a\u0000\u0002" +
                "\u150a\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.EncryptedData> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.EncryptedData.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.EncryptedData>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.EncryptedData)
    private static final org.bitcoinj.wallet.Protos.EncryptedData DEFAULT_INSTANCE;
    static {
      EncryptedData defaultInstance = new EncryptedData();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EncryptedData.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.EncryptedData getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EncryptedData> PARSER;

    public static com.google.protobuf.Parser<EncryptedData> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DeterministicKeyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.DeterministicKey)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
     * should just treat it as a regular ORIGINAL type key.
     * </pre>
     *
     * <code>required bytes chain_code = 1;</code>
     * @return Whether the chainCode field is set.
     */
    boolean hasChainCode();
    /**
     * <pre>
     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
     * should just treat it as a regular ORIGINAL type key.
     * </pre>
     *
     * <code>required bytes chain_code = 1;</code>
     * @return The chainCode.
     */
    com.google.protobuf.ByteString getChainCode();

    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     * @return A list containing the path.
     */
    java.util.List<java.lang.Integer> getPathList();
    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     * @return The count of path.
     */
    int getPathCount();
    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     * @param index The index of the element to return.
     * @return The path at the given index.
     */
    int getPath(int index);

    /**
     * <pre>
     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
     * If this field is missing it means we're not issuing subkeys of this key to users.
     * </pre>
     *
     * <code>optional uint32 issued_subkeys = 3;</code>
     * @return Whether the issuedSubkeys field is set.
     */
    boolean hasIssuedSubkeys();
    /**
     * <pre>
     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
     * If this field is missing it means we're not issuing subkeys of this key to users.
     * </pre>
     *
     * <code>optional uint32 issued_subkeys = 3;</code>
     * @return The issuedSubkeys.
     */
    int getIssuedSubkeys();

    /**
     * <code>optional uint32 lookahead_size = 4;</code>
     * @return Whether the lookaheadSize field is set.
     */
    boolean hasLookaheadSize();
    /**
     * <code>optional uint32 lookahead_size = 4;</code>
     * @return The lookaheadSize.
     */
    int getLookaheadSize();

    /**
     * <pre>
     **
     * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
     * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
     * a single P2SH multisignature address
     * </pre>
     *
     * <code>optional bool isFollowing = 5;</code>
     * @return Whether the isFollowing field is set.
     */
    boolean hasIsFollowing();
    /**
     * <pre>
     **
     * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
     * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
     * a single P2SH multisignature address
     * </pre>
     *
     * <code>optional bool isFollowing = 5;</code>
     * @return The isFollowing.
     */
    boolean getIsFollowing();

    /**
     * <pre>
     * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
     * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
     * </pre>
     *
     * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
     * @return Whether the sigsRequiredToSpend field is set.
     */
    boolean hasSigsRequiredToSpend();
    /**
     * <pre>
     * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
     * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
     * </pre>
     *
     * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
     * @return The sigsRequiredToSpend.
     */
    int getSigsRequiredToSpend();
  }
  /**
   * <pre>
   **
   * Data attached to a Key message that defines the data needed by the BIP32 deterministic key hierarchy algorithm.
   * </pre>
   *
   * Protobuf type {@code wallet.DeterministicKey}
   */
  public  static final class DeterministicKey extends
      com.google.protobuf.GeneratedMessageLite<
          DeterministicKey, DeterministicKey.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.DeterministicKey)
      DeterministicKeyOrBuilder {
    private DeterministicKey() {
      chainCode_ = com.google.protobuf.ByteString.EMPTY;
      path_ = emptyIntList();
      sigsRequiredToSpend_ = 1;
    }
    private int bitField0_;
    public static final int CHAIN_CODE_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString chainCode_;
    /**
     * <pre>
     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
     * should just treat it as a regular ORIGINAL type key.
     * </pre>
     *
     * <code>required bytes chain_code = 1;</code>
     * @return Whether the chainCode field is set.
     */
    @java.lang.Override
    public boolean hasChainCode() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
     * should just treat it as a regular ORIGINAL type key.
     * </pre>
     *
     * <code>required bytes chain_code = 1;</code>
     * @return The chainCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getChainCode() {
      return chainCode_;
    }
    /**
     * <pre>
     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
     * should just treat it as a regular ORIGINAL type key.
     * </pre>
     *
     * <code>required bytes chain_code = 1;</code>
     * @param value The chainCode to set.
     */
    private void setChainCode(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      chainCode_ = value;
    }
    /**
     * <pre>
     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
     * should just treat it as a regular ORIGINAL type key.
     * </pre>
     *
     * <code>required bytes chain_code = 1;</code>
     */
    private void clearChainCode() {
      bitField0_ = (bitField0_ & ~0x00000001);
      chainCode_ = getDefaultInstance().getChainCode();
    }

    public static final int PATH_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.IntList path_;
    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     * @return A list containing the path.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getPathList() {
      return path_;
    }
    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     * @return The count of path.
     */
    @java.lang.Override
    public int getPathCount() {
      return path_.size();
    }
    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     * @param index The index of the element to return.
     * @return The path at the given index.
     */
    @java.lang.Override
    public int getPath(int index) {
      return path_.getInt(index);
    }
    private void ensurePathIsMutable() {
      com.google.protobuf.Internal.IntList tmp = path_;
      if (!tmp.isModifiable()) {
        path_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     * @param index The index to set the value at.
     * @param value The path to set.
     */
    private void setPath(
        int index, int value) {
      ensurePathIsMutable();
      path_.setInt(index, value);
    }
    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     * @param value The path to add.
     */
    private void addPath(int value) {
      ensurePathIsMutable();
      path_.addInt(value);
    }
    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     * @param values The path to add.
     */
    private void addAllPath(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensurePathIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, path_);
    }
    /**
     * <pre>
     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
     * and high bit unset for public derivation.
     * </pre>
     *
     * <code>repeated uint32 path = 2;</code>
     */
    private void clearPath() {
      path_ = emptyIntList();
    }

    public static final int ISSUED_SUBKEYS_FIELD_NUMBER = 3;
    private int issuedSubkeys_;
    /**
     * <pre>
     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
     * If this field is missing it means we're not issuing subkeys of this key to users.
     * </pre>
     *
     * <code>optional uint32 issued_subkeys = 3;</code>
     * @return Whether the issuedSubkeys field is set.
     */
    @java.lang.Override
    public boolean hasIssuedSubkeys() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
     * If this field is missing it means we're not issuing subkeys of this key to users.
     * </pre>
     *
     * <code>optional uint32 issued_subkeys = 3;</code>
     * @return The issuedSubkeys.
     */
    @java.lang.Override
    public int getIssuedSubkeys() {
      return issuedSubkeys_;
    }
    /**
     * <pre>
     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
     * If this field is missing it means we're not issuing subkeys of this key to users.
     * </pre>
     *
     * <code>optional uint32 issued_subkeys = 3;</code>
     * @param value The issuedSubkeys to set.
     */
    private void setIssuedSubkeys(int value) {
      bitField0_ |= 0x00000002;
      issuedSubkeys_ = value;
    }
    /**
     * <pre>
     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
     * If this field is missing it means we're not issuing subkeys of this key to users.
     * </pre>
     *
     * <code>optional uint32 issued_subkeys = 3;</code>
     */
    private void clearIssuedSubkeys() {
      bitField0_ = (bitField0_ & ~0x00000002);
      issuedSubkeys_ = 0;
    }

    public static final int LOOKAHEAD_SIZE_FIELD_NUMBER = 4;
    private int lookaheadSize_;
    /**
     * <code>optional uint32 lookahead_size = 4;</code>
     * @return Whether the lookaheadSize field is set.
     */
    @java.lang.Override
    public boolean hasLookaheadSize() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional uint32 lookahead_size = 4;</code>
     * @return The lookaheadSize.
     */
    @java.lang.Override
    public int getLookaheadSize() {
      return lookaheadSize_;
    }
    /**
     * <code>optional uint32 lookahead_size = 4;</code>
     * @param value The lookaheadSize to set.
     */
    private void setLookaheadSize(int value) {
      bitField0_ |= 0x00000004;
      lookaheadSize_ = value;
    }
    /**
     * <code>optional uint32 lookahead_size = 4;</code>
     */
    private void clearLookaheadSize() {
      bitField0_ = (bitField0_ & ~0x00000004);
      lookaheadSize_ = 0;
    }

    public static final int ISFOLLOWING_FIELD_NUMBER = 5;
    private boolean isFollowing_;
    /**
     * <pre>
     **
     * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
     * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
     * a single P2SH multisignature address
     * </pre>
     *
     * <code>optional bool isFollowing = 5;</code>
     * @return Whether the isFollowing field is set.
     */
    @java.lang.Override
    public boolean hasIsFollowing() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     **
     * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
     * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
     * a single P2SH multisignature address
     * </pre>
     *
     * <code>optional bool isFollowing = 5;</code>
     * @return The isFollowing.
     */
    @java.lang.Override
    public boolean getIsFollowing() {
      return isFollowing_;
    }
    /**
     * <pre>
     **
     * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
     * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
     * a single P2SH multisignature address
     * </pre>
     *
     * <code>optional bool isFollowing = 5;</code>
     * @param value The isFollowing to set.
     */
    private void setIsFollowing(boolean value) {
      bitField0_ |= 0x00000008;
      isFollowing_ = value;
    }
    /**
     * <pre>
     **
     * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
     * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
     * a single P2SH multisignature address
     * </pre>
     *
     * <code>optional bool isFollowing = 5;</code>
     */
    private void clearIsFollowing() {
      bitField0_ = (bitField0_ & ~0x00000008);
      isFollowing_ = false;
    }

    public static final int SIGSREQUIREDTOSPEND_FIELD_NUMBER = 6;
    private int sigsRequiredToSpend_;
    /**
     * <pre>
     * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
     * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
     * </pre>
     *
     * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
     * @return Whether the sigsRequiredToSpend field is set.
     */
    @java.lang.Override
    public boolean hasSigsRequiredToSpend() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
     * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
     * </pre>
     *
     * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
     * @return The sigsRequiredToSpend.
     */
    @java.lang.Override
    public int getSigsRequiredToSpend() {
      return sigsRequiredToSpend_;
    }
    /**
     * <pre>
     * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
     * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
     * </pre>
     *
     * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
     * @param value The sigsRequiredToSpend to set.
     */
    private void setSigsRequiredToSpend(int value) {
      bitField0_ |= 0x00000010;
      sigsRequiredToSpend_ = value;
    }
    /**
     * <pre>
     * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
     * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
     * </pre>
     *
     * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
     */
    private void clearSigsRequiredToSpend() {
      bitField0_ = (bitField0_ & ~0x00000010);
      sigsRequiredToSpend_ = 1;
    }

    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.DeterministicKey prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     **
     * Data attached to a Key message that defines the data needed by the BIP32 deterministic key hierarchy algorithm.
     * </pre>
     *
     * Protobuf type {@code wallet.DeterministicKey}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.DeterministicKey, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.DeterministicKey)
        org.bitcoinj.wallet.Protos.DeterministicKeyOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.DeterministicKey.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
       * should just treat it as a regular ORIGINAL type key.
       * </pre>
       *
       * <code>required bytes chain_code = 1;</code>
       * @return Whether the chainCode field is set.
       */
      @java.lang.Override
      public boolean hasChainCode() {
        return instance.hasChainCode();
      }
      /**
       * <pre>
       * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
       * should just treat it as a regular ORIGINAL type key.
       * </pre>
       *
       * <code>required bytes chain_code = 1;</code>
       * @return The chainCode.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getChainCode() {
        return instance.getChainCode();
      }
      /**
       * <pre>
       * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
       * should just treat it as a regular ORIGINAL type key.
       * </pre>
       *
       * <code>required bytes chain_code = 1;</code>
       * @param value The chainCode to set.
       * @return This builder for chaining.
       */
      public Builder setChainCode(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChainCode(value);
        return this;
      }
      /**
       * <pre>
       * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
       * should just treat it as a regular ORIGINAL type key.
       * </pre>
       *
       * <code>required bytes chain_code = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearChainCode() {
        copyOnWrite();
        instance.clearChainCode();
        return this;
      }

      /**
       * <pre>
       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
       * and high bit unset for public derivation.
       * </pre>
       *
       * <code>repeated uint32 path = 2;</code>
       * @return A list containing the path.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getPathList() {
        return java.util.Collections.unmodifiableList(
            instance.getPathList());
      }
      /**
       * <pre>
       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
       * and high bit unset for public derivation.
       * </pre>
       *
       * <code>repeated uint32 path = 2;</code>
       * @return The count of path.
       */
      @java.lang.Override
      public int getPathCount() {
        return instance.getPathCount();
      }
      /**
       * <pre>
       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
       * and high bit unset for public derivation.
       * </pre>
       *
       * <code>repeated uint32 path = 2;</code>
       * @param index The index of the element to return.
       * @return The path at the given index.
       */
      @java.lang.Override
      public int getPath(int index) {
        return instance.getPath(index);
      }
      /**
       * <pre>
       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
       * and high bit unset for public derivation.
       * </pre>
       *
       * <code>repeated uint32 path = 2;</code>
       * @param value The path to set.
       * @return This builder for chaining.
       */
      public Builder setPath(
          int index, int value) {
        copyOnWrite();
        instance.setPath(index, value);
        return this;
      }
      /**
       * <pre>
       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
       * and high bit unset for public derivation.
       * </pre>
       *
       * <code>repeated uint32 path = 2;</code>
       * @param value The path to add.
       * @return This builder for chaining.
       */
      public Builder addPath(int value) {
        copyOnWrite();
        instance.addPath(value);
        return this;
      }
      /**
       * <pre>
       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
       * and high bit unset for public derivation.
       * </pre>
       *
       * <code>repeated uint32 path = 2;</code>
       * @param values The path to add.
       * @return This builder for chaining.
       */
      public Builder addAllPath(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllPath(values);
        return this;
      }
      /**
       * <pre>
       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
       * and high bit unset for public derivation.
       * </pre>
       *
       * <code>repeated uint32 path = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPath() {
        copyOnWrite();
        instance.clearPath();
        return this;
      }

      /**
       * <pre>
       * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
       * For the parents of keys being handed out, this is always less than the true number of children: the difference is
       * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
       * this wallet - for instance when restoring from backup or if the seed was shared between devices.
       * If this field is missing it means we're not issuing subkeys of this key to users.
       * </pre>
       *
       * <code>optional uint32 issued_subkeys = 3;</code>
       * @return Whether the issuedSubkeys field is set.
       */
      @java.lang.Override
      public boolean hasIssuedSubkeys() {
        return instance.hasIssuedSubkeys();
      }
      /**
       * <pre>
       * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
       * For the parents of keys being handed out, this is always less than the true number of children: the difference is
       * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
       * this wallet - for instance when restoring from backup or if the seed was shared between devices.
       * If this field is missing it means we're not issuing subkeys of this key to users.
       * </pre>
       *
       * <code>optional uint32 issued_subkeys = 3;</code>
       * @return The issuedSubkeys.
       */
      @java.lang.Override
      public int getIssuedSubkeys() {
        return instance.getIssuedSubkeys();
      }
      /**
       * <pre>
       * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
       * For the parents of keys being handed out, this is always less than the true number of children: the difference is
       * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
       * this wallet - for instance when restoring from backup or if the seed was shared between devices.
       * If this field is missing it means we're not issuing subkeys of this key to users.
       * </pre>
       *
       * <code>optional uint32 issued_subkeys = 3;</code>
       * @param value The issuedSubkeys to set.
       * @return This builder for chaining.
       */
      public Builder setIssuedSubkeys(int value) {
        copyOnWrite();
        instance.setIssuedSubkeys(value);
        return this;
      }
      /**
       * <pre>
       * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
       * For the parents of keys being handed out, this is always less than the true number of children: the difference is
       * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
       * this wallet - for instance when restoring from backup or if the seed was shared between devices.
       * If this field is missing it means we're not issuing subkeys of this key to users.
       * </pre>
       *
       * <code>optional uint32 issued_subkeys = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIssuedSubkeys() {
        copyOnWrite();
        instance.clearIssuedSubkeys();
        return this;
      }

      /**
       * <code>optional uint32 lookahead_size = 4;</code>
       * @return Whether the lookaheadSize field is set.
       */
      @java.lang.Override
      public boolean hasLookaheadSize() {
        return instance.hasLookaheadSize();
      }
      /**
       * <code>optional uint32 lookahead_size = 4;</code>
       * @return The lookaheadSize.
       */
      @java.lang.Override
      public int getLookaheadSize() {
        return instance.getLookaheadSize();
      }
      /**
       * <code>optional uint32 lookahead_size = 4;</code>
       * @param value The lookaheadSize to set.
       * @return This builder for chaining.
       */
      public Builder setLookaheadSize(int value) {
        copyOnWrite();
        instance.setLookaheadSize(value);
        return this;
      }
      /**
       * <code>optional uint32 lookahead_size = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLookaheadSize() {
        copyOnWrite();
        instance.clearLookaheadSize();
        return this;
      }

      /**
       * <pre>
       **
       * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
       * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
       * a single P2SH multisignature address
       * </pre>
       *
       * <code>optional bool isFollowing = 5;</code>
       * @return Whether the isFollowing field is set.
       */
      @java.lang.Override
      public boolean hasIsFollowing() {
        return instance.hasIsFollowing();
      }
      /**
       * <pre>
       **
       * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
       * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
       * a single P2SH multisignature address
       * </pre>
       *
       * <code>optional bool isFollowing = 5;</code>
       * @return The isFollowing.
       */
      @java.lang.Override
      public boolean getIsFollowing() {
        return instance.getIsFollowing();
      }
      /**
       * <pre>
       **
       * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
       * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
       * a single P2SH multisignature address
       * </pre>
       *
       * <code>optional bool isFollowing = 5;</code>
       * @param value The isFollowing to set.
       * @return This builder for chaining.
       */
      public Builder setIsFollowing(boolean value) {
        copyOnWrite();
        instance.setIsFollowing(value);
        return this;
      }
      /**
       * <pre>
       **
       * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
       * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
       * a single P2SH multisignature address
       * </pre>
       *
       * <code>optional bool isFollowing = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsFollowing() {
        copyOnWrite();
        instance.clearIsFollowing();
        return this;
      }

      /**
       * <pre>
       * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
       * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
       * </pre>
       *
       * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
       * @return Whether the sigsRequiredToSpend field is set.
       */
      @java.lang.Override
      public boolean hasSigsRequiredToSpend() {
        return instance.hasSigsRequiredToSpend();
      }
      /**
       * <pre>
       * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
       * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
       * </pre>
       *
       * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
       * @return The sigsRequiredToSpend.
       */
      @java.lang.Override
      public int getSigsRequiredToSpend() {
        return instance.getSigsRequiredToSpend();
      }
      /**
       * <pre>
       * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
       * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
       * </pre>
       *
       * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
       * @param value The sigsRequiredToSpend to set.
       * @return This builder for chaining.
       */
      public Builder setSigsRequiredToSpend(int value) {
        copyOnWrite();
        instance.setSigsRequiredToSpend(value);
        return this;
      }
      /**
       * <pre>
       * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
       * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
       * </pre>
       *
       * <code>optional uint32 sigsRequiredToSpend = 6 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearSigsRequiredToSpend() {
        copyOnWrite();
        instance.clearSigsRequiredToSpend();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.DeterministicKey)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.DeterministicKey();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "chainCode_",
              "path_",
              "issuedSubkeys_",
              "lookaheadSize_",
              "isFollowing_",
              "sigsRequiredToSpend_",
            };
            java.lang.String info =
                "\u0001\u0006\u0000\u0001\u0001\u0006\u0006\u0000\u0001\u0001\u0001\u150a\u0000\u0002" +
                "\u001d\u0003\u100b\u0001\u0004\u100b\u0002\u0005\u1007\u0003\u0006\u100b\u0004";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.DeterministicKey> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.DeterministicKey.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.DeterministicKey>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.DeterministicKey)
    private static final org.bitcoinj.wallet.Protos.DeterministicKey DEFAULT_INSTANCE;
    static {
      DeterministicKey defaultInstance = new DeterministicKey();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DeterministicKey.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.DeterministicKey getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DeterministicKey> PARSER;

    public static com.google.protobuf.Parser<DeterministicKey> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface KeyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.Key)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required .wallet.Key.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .wallet.Key.Type type = 1;</code>
     * @return The type.
     */
    org.bitcoinj.wallet.Protos.Key.Type getType();

    /**
     * <pre>
     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
     * If the secret is encrypted, or this is a "watching entry" then this is missing.
     * </pre>
     *
     * <code>optional bytes secret_bytes = 2;</code>
     * @return Whether the secretBytes field is set.
     */
    boolean hasSecretBytes();
    /**
     * <pre>
     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
     * If the secret is encrypted, or this is a "watching entry" then this is missing.
     * </pre>
     *
     * <code>optional bytes secret_bytes = 2;</code>
     * @return The secretBytes.
     */
    com.google.protobuf.ByteString getSecretBytes();

    /**
     * <pre>
     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
     * @return Whether the encryptedData field is set.
     */
    boolean hasEncryptedData();
    /**
     * <pre>
     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
     * @return The encryptedData.
     */
    org.bitcoinj.wallet.Protos.EncryptedData getEncryptedData();

    /**
     * <pre>
     * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
     * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
     * </pre>
     *
     * <code>optional bytes public_key = 3;</code>
     * @return Whether the publicKey field is set.
     */
    boolean hasPublicKey();
    /**
     * <pre>
     * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
     * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
     * </pre>
     *
     * <code>optional bytes public_key = 3;</code>
     * @return The publicKey.
     */
    com.google.protobuf.ByteString getPublicKey();

    /**
     * <pre>
     * User-provided label associated with the key.
     * </pre>
     *
     * <code>optional string label = 4;</code>
     * @return Whether the label field is set.
     */
    boolean hasLabel();
    /**
     * <pre>
     * User-provided label associated with the key.
     * </pre>
     *
     * <code>optional string label = 4;</code>
     * @return The label.
     */
    java.lang.String getLabel();
    /**
     * <pre>
     * User-provided label associated with the key.
     * </pre>
     *
     * <code>optional string label = 4;</code>
     * @return The bytes for label.
     */
    com.google.protobuf.ByteString
        getLabelBytes();

    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
     * optional is that keys derived from a parent don't have this data.
     * </pre>
     *
     * <code>optional int64 creation_timestamp = 5;</code>
     * @return Whether the creationTimestamp field is set.
     */
    boolean hasCreationTimestamp();
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
     * optional is that keys derived from a parent don't have this data.
     * </pre>
     *
     * <code>optional int64 creation_timestamp = 5;</code>
     * @return The creationTimestamp.
     */
    long getCreationTimestamp();

    /**
     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
     * @return Whether the deterministicKey field is set.
     */
    boolean hasDeterministicKey();
    /**
     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
     * @return The deterministicKey.
     */
    org.bitcoinj.wallet.Protos.DeterministicKey getDeterministicKey();

    /**
     * <pre>
     * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
     * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>optional bytes deterministic_seed = 8;</code>
     * @return Whether the deterministicSeed field is set.
     */
    boolean hasDeterministicSeed();
    /**
     * <pre>
     * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
     * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>optional bytes deterministic_seed = 8;</code>
     * @return The deterministicSeed.
     */
    com.google.protobuf.ByteString getDeterministicSeed();

    /**
     * <pre>
     * Encrypted version of the seed
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
     * @return Whether the encryptedDeterministicSeed field is set.
     */
    boolean hasEncryptedDeterministicSeed();
    /**
     * <pre>
     * Encrypted version of the seed
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
     * @return The encryptedDeterministicSeed.
     */
    org.bitcoinj.wallet.Protos.EncryptedData getEncryptedDeterministicSeed();

    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     * @return A list containing the accountPath.
     */
    java.util.List<java.lang.Integer> getAccountPathList();
    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     * @return The count of accountPath.
     */
    int getAccountPathCount();
    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The accountPath at the given index.
     */
    int getAccountPath(int index);

    /**
     * <pre>
     * Type of addresses (aka output scripts) to generate for receiving.
     * </pre>
     *
     * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
     * @return Whether the outputScriptType field is set.
     */
    boolean hasOutputScriptType();
    /**
     * <pre>
     * Type of addresses (aka output scripts) to generate for receiving.
     * </pre>
     *
     * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
     * @return The outputScriptType.
     */
    org.bitcoinj.wallet.Protos.Key.OutputScriptType getOutputScriptType();
  }
  /**
   * <pre>
   **
   * A key used to control Bitcoin spending.
   * Either the private key, the public key or both may be present.  It is recommended that
   * if the private key is provided that the public key is provided too because deriving it is slow.
   * If only the public key is provided, the key can only be used to watch the blockchain and verify
   * transactions, and not for spending.
   * </pre>
   *
   * Protobuf type {@code wallet.Key}
   */
  public  static final class Key extends
      com.google.protobuf.GeneratedMessageLite<
          Key, Key.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.Key)
      KeyOrBuilder {
    private Key() {
      type_ = 1;
      secretBytes_ = com.google.protobuf.ByteString.EMPTY;
      publicKey_ = com.google.protobuf.ByteString.EMPTY;
      label_ = "";
      deterministicSeed_ = com.google.protobuf.ByteString.EMPTY;
      accountPath_ = emptyIntList();
      outputScriptType_ = 1;
    }
    /**
     * Protobuf enum {@code wallet.Key.Type}
     */
    public enum Type
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       ** Unencrypted - Original bitcoin secp256k1 curve 
       * </pre>
       *
       * <code>ORIGINAL = 1;</code>
       */
      ORIGINAL(1),
      /**
       * <pre>
       ** Encrypted with Scrypt and AES - Original bitcoin secp256k1 curve 
       * </pre>
       *
       * <code>ENCRYPTED_SCRYPT_AES = 2;</code>
       */
      ENCRYPTED_SCRYPT_AES(2),
      /**
       * <pre>
       **
       * Not really a key, but rather contains the mnemonic phrase for a deterministic key hierarchy in the private_key field.
       * The label and public_key fields are missing. Creation timestamp will exist.
       * </pre>
       *
       * <code>DETERMINISTIC_MNEMONIC = 3;</code>
       */
      DETERMINISTIC_MNEMONIC(3),
      /**
       * <pre>
       **
       * A key that was derived deterministically. Note that the root seed that created it may NOT be present in the
       * wallet, for the case of watching wallets. A deterministic key may or may not have the private key bytes present.
       * However the public key bytes and the deterministic_key field are guaranteed to exist. In a wallet where there
       * is a path from this key up to a key that has (possibly encrypted) private bytes, it's expected that the private
       * key can be rederived on the fly.
       * </pre>
       *
       * <code>DETERMINISTIC_KEY = 4;</code>
       */
      DETERMINISTIC_KEY(4),
      ;

      /**
       * <pre>
       ** Unencrypted - Original bitcoin secp256k1 curve 
       * </pre>
       *
       * <code>ORIGINAL = 1;</code>
       */
      public static final int ORIGINAL_VALUE = 1;
      /**
       * <pre>
       ** Encrypted with Scrypt and AES - Original bitcoin secp256k1 curve 
       * </pre>
       *
       * <code>ENCRYPTED_SCRYPT_AES = 2;</code>
       */
      public static final int ENCRYPTED_SCRYPT_AES_VALUE = 2;
      /**
       * <pre>
       **
       * Not really a key, but rather contains the mnemonic phrase for a deterministic key hierarchy in the private_key field.
       * The label and public_key fields are missing. Creation timestamp will exist.
       * </pre>
       *
       * <code>DETERMINISTIC_MNEMONIC = 3;</code>
       */
      public static final int DETERMINISTIC_MNEMONIC_VALUE = 3;
      /**
       * <pre>
       **
       * A key that was derived deterministically. Note that the root seed that created it may NOT be present in the
       * wallet, for the case of watching wallets. A deterministic key may or may not have the private key bytes present.
       * However the public key bytes and the deterministic_key field are guaranteed to exist. In a wallet where there
       * is a path from this key up to a key that has (possibly encrypted) private bytes, it's expected that the private
       * key can be rederived on the fly.
       * </pre>
       *
       * <code>DETERMINISTIC_KEY = 4;</code>
       */
      public static final int DETERMINISTIC_KEY_VALUE = 4;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      public static Type forNumber(int value) {
        switch (value) {
          case 1: return ORIGINAL;
          case 2: return ENCRYPTED_SCRYPT_AES;
          case 3: return DETERMINISTIC_MNEMONIC;
          case 4: return DETERMINISTIC_KEY;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              @java.lang.Override
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return TypeVerifier.INSTANCE;
      }

      private static final class TypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new TypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Type.forNumber(number) != null;
              }
            };

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:wallet.Key.Type)
    }

    /**
     * Protobuf enum {@code wallet.Key.OutputScriptType}
     */
    public enum OutputScriptType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>P2PKH = 1;</code>
       */
      P2PKH(1),
      /**
       * <code>P2WPKH = 2;</code>
       */
      P2WPKH(2),
      ;

      /**
       * <code>P2PKH = 1;</code>
       */
      public static final int P2PKH_VALUE = 1;
      /**
       * <code>P2WPKH = 2;</code>
       */
      public static final int P2WPKH_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static OutputScriptType valueOf(int value) {
        return forNumber(value);
      }

      public static OutputScriptType forNumber(int value) {
        switch (value) {
          case 1: return P2PKH;
          case 2: return P2WPKH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<OutputScriptType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          OutputScriptType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<OutputScriptType>() {
              @java.lang.Override
              public OutputScriptType findValueByNumber(int number) {
                return OutputScriptType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return OutputScriptTypeVerifier.INSTANCE;
      }

      private static final class OutputScriptTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new OutputScriptTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return OutputScriptType.forNumber(number) != null;
              }
            };

      private final int value;

      private OutputScriptType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:wallet.Key.OutputScriptType)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>required .wallet.Key.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .wallet.Key.Type type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Key.Type getType() {
      org.bitcoinj.wallet.Protos.Key.Type result = org.bitcoinj.wallet.Protos.Key.Type.forNumber(type_);
      return result == null ? org.bitcoinj.wallet.Protos.Key.Type.ORIGINAL : result;
    }
    /**
     * <code>required .wallet.Key.Type type = 1;</code>
     * @param value The type to set.
     */
    private void setType(org.bitcoinj.wallet.Protos.Key.Type value) {
      type_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>required .wallet.Key.Type type = 1;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      type_ = 1;
    }

    public static final int SECRET_BYTES_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString secretBytes_;
    /**
     * <pre>
     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
     * If the secret is encrypted, or this is a "watching entry" then this is missing.
     * </pre>
     *
     * <code>optional bytes secret_bytes = 2;</code>
     * @return Whether the secretBytes field is set.
     */
    @java.lang.Override
    public boolean hasSecretBytes() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
     * If the secret is encrypted, or this is a "watching entry" then this is missing.
     * </pre>
     *
     * <code>optional bytes secret_bytes = 2;</code>
     * @return The secretBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSecretBytes() {
      return secretBytes_;
    }
    /**
     * <pre>
     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
     * If the secret is encrypted, or this is a "watching entry" then this is missing.
     * </pre>
     *
     * <code>optional bytes secret_bytes = 2;</code>
     * @param value The secretBytes to set.
     */
    private void setSecretBytes(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      secretBytes_ = value;
    }
    /**
     * <pre>
     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
     * If the secret is encrypted, or this is a "watching entry" then this is missing.
     * </pre>
     *
     * <code>optional bytes secret_bytes = 2;</code>
     */
    private void clearSecretBytes() {
      bitField0_ = (bitField0_ & ~0x00000002);
      secretBytes_ = getDefaultInstance().getSecretBytes();
    }

    public static final int ENCRYPTED_DATA_FIELD_NUMBER = 6;
    private org.bitcoinj.wallet.Protos.EncryptedData encryptedData_;
    /**
     * <pre>
     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
     */
    @java.lang.Override
    public boolean hasEncryptedData() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.EncryptedData getEncryptedData() {
      return encryptedData_ == null ? org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance() : encryptedData_;
    }
    /**
     * <pre>
     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
     */
    private void setEncryptedData(org.bitcoinj.wallet.Protos.EncryptedData value) {
      value.getClass();
  encryptedData_ = value;
      bitField0_ |= 0x00000004;
      }
    /**
     * <pre>
     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeEncryptedData(org.bitcoinj.wallet.Protos.EncryptedData value) {
      value.getClass();
  if (encryptedData_ != null &&
          encryptedData_ != org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance()) {
        encryptedData_ =
          org.bitcoinj.wallet.Protos.EncryptedData.newBuilder(encryptedData_).mergeFrom(value).buildPartial();
      } else {
        encryptedData_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
     */
    private void clearEncryptedData() {  encryptedData_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int PUBLIC_KEY_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString publicKey_;
    /**
     * <pre>
     * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
     * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
     * </pre>
     *
     * <code>optional bytes public_key = 3;</code>
     * @return Whether the publicKey field is set.
     */
    @java.lang.Override
    public boolean hasPublicKey() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
     * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
     * </pre>
     *
     * <code>optional bytes public_key = 3;</code>
     * @return The publicKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPublicKey() {
      return publicKey_;
    }
    /**
     * <pre>
     * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
     * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
     * </pre>
     *
     * <code>optional bytes public_key = 3;</code>
     * @param value The publicKey to set.
     */
    private void setPublicKey(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000008;
      publicKey_ = value;
    }
    /**
     * <pre>
     * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
     * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
     * </pre>
     *
     * <code>optional bytes public_key = 3;</code>
     */
    private void clearPublicKey() {
      bitField0_ = (bitField0_ & ~0x00000008);
      publicKey_ = getDefaultInstance().getPublicKey();
    }

    public static final int LABEL_FIELD_NUMBER = 4;
    private java.lang.String label_;
    /**
     * <pre>
     * User-provided label associated with the key.
     * </pre>
     *
     * <code>optional string label = 4;</code>
     * @return Whether the label field is set.
     */
    @java.lang.Override
    public boolean hasLabel() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * User-provided label associated with the key.
     * </pre>
     *
     * <code>optional string label = 4;</code>
     * @return The label.
     */
    @java.lang.Override
    public java.lang.String getLabel() {
      return label_;
    }
    /**
     * <pre>
     * User-provided label associated with the key.
     * </pre>
     *
     * <code>optional string label = 4;</code>
     * @return The bytes for label.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(label_);
    }
    /**
     * <pre>
     * User-provided label associated with the key.
     * </pre>
     *
     * <code>optional string label = 4;</code>
     * @param value The label to set.
     */
    private void setLabel(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000010;
      label_ = value;
    }
    /**
     * <pre>
     * User-provided label associated with the key.
     * </pre>
     *
     * <code>optional string label = 4;</code>
     */
    private void clearLabel() {
      bitField0_ = (bitField0_ & ~0x00000010);
      label_ = getDefaultInstance().getLabel();
    }
    /**
     * <pre>
     * User-provided label associated with the key.
     * </pre>
     *
     * <code>optional string label = 4;</code>
     * @param value The bytes for label to set.
     */
    private void setLabelBytes(
        com.google.protobuf.ByteString value) {
      label_ = value.toStringUtf8();
      bitField0_ |= 0x00000010;
    }

    public static final int CREATION_TIMESTAMP_FIELD_NUMBER = 5;
    private long creationTimestamp_;
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
     * optional is that keys derived from a parent don't have this data.
     * </pre>
     *
     * <code>optional int64 creation_timestamp = 5;</code>
     * @return Whether the creationTimestamp field is set.
     */
    @java.lang.Override
    public boolean hasCreationTimestamp() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
     * optional is that keys derived from a parent don't have this data.
     * </pre>
     *
     * <code>optional int64 creation_timestamp = 5;</code>
     * @return The creationTimestamp.
     */
    @java.lang.Override
    public long getCreationTimestamp() {
      return creationTimestamp_;
    }
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
     * optional is that keys derived from a parent don't have this data.
     * </pre>
     *
     * <code>optional int64 creation_timestamp = 5;</code>
     * @param value The creationTimestamp to set.
     */
    private void setCreationTimestamp(long value) {
      bitField0_ |= 0x00000020;
      creationTimestamp_ = value;
    }
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
     * optional is that keys derived from a parent don't have this data.
     * </pre>
     *
     * <code>optional int64 creation_timestamp = 5;</code>
     */
    private void clearCreationTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000020);
      creationTimestamp_ = 0L;
    }

    public static final int DETERMINISTIC_KEY_FIELD_NUMBER = 7;
    private org.bitcoinj.wallet.Protos.DeterministicKey deterministicKey_;
    /**
     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
     */
    @java.lang.Override
    public boolean hasDeterministicKey() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.DeterministicKey getDeterministicKey() {
      return deterministicKey_ == null ? org.bitcoinj.wallet.Protos.DeterministicKey.getDefaultInstance() : deterministicKey_;
    }
    /**
     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
     */
    private void setDeterministicKey(org.bitcoinj.wallet.Protos.DeterministicKey value) {
      value.getClass();
  deterministicKey_ = value;
      bitField0_ |= 0x00000040;
      }
    /**
     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeDeterministicKey(org.bitcoinj.wallet.Protos.DeterministicKey value) {
      value.getClass();
  if (deterministicKey_ != null &&
          deterministicKey_ != org.bitcoinj.wallet.Protos.DeterministicKey.getDefaultInstance()) {
        deterministicKey_ =
          org.bitcoinj.wallet.Protos.DeterministicKey.newBuilder(deterministicKey_).mergeFrom(value).buildPartial();
      } else {
        deterministicKey_ = value;
      }
      bitField0_ |= 0x00000040;
    }
    /**
     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
     */
    private void clearDeterministicKey() {  deterministicKey_ = null;
      bitField0_ = (bitField0_ & ~0x00000040);
    }

    public static final int DETERMINISTIC_SEED_FIELD_NUMBER = 8;
    private com.google.protobuf.ByteString deterministicSeed_;
    /**
     * <pre>
     * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
     * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>optional bytes deterministic_seed = 8;</code>
     * @return Whether the deterministicSeed field is set.
     */
    @java.lang.Override
    public boolean hasDeterministicSeed() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
     * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>optional bytes deterministic_seed = 8;</code>
     * @return The deterministicSeed.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getDeterministicSeed() {
      return deterministicSeed_;
    }
    /**
     * <pre>
     * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
     * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>optional bytes deterministic_seed = 8;</code>
     * @param value The deterministicSeed to set.
     */
    private void setDeterministicSeed(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000080;
      deterministicSeed_ = value;
    }
    /**
     * <pre>
     * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
     * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>optional bytes deterministic_seed = 8;</code>
     */
    private void clearDeterministicSeed() {
      bitField0_ = (bitField0_ & ~0x00000080);
      deterministicSeed_ = getDefaultInstance().getDeterministicSeed();
    }

    public static final int ENCRYPTED_DETERMINISTIC_SEED_FIELD_NUMBER = 9;
    private org.bitcoinj.wallet.Protos.EncryptedData encryptedDeterministicSeed_;
    /**
     * <pre>
     * Encrypted version of the seed
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
     */
    @java.lang.Override
    public boolean hasEncryptedDeterministicSeed() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Encrypted version of the seed
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.EncryptedData getEncryptedDeterministicSeed() {
      return encryptedDeterministicSeed_ == null ? org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance() : encryptedDeterministicSeed_;
    }
    /**
     * <pre>
     * Encrypted version of the seed
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
     */
    private void setEncryptedDeterministicSeed(org.bitcoinj.wallet.Protos.EncryptedData value) {
      value.getClass();
  encryptedDeterministicSeed_ = value;
      bitField0_ |= 0x00000100;
      }
    /**
     * <pre>
     * Encrypted version of the seed
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeEncryptedDeterministicSeed(org.bitcoinj.wallet.Protos.EncryptedData value) {
      value.getClass();
  if (encryptedDeterministicSeed_ != null &&
          encryptedDeterministicSeed_ != org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance()) {
        encryptedDeterministicSeed_ =
          org.bitcoinj.wallet.Protos.EncryptedData.newBuilder(encryptedDeterministicSeed_).mergeFrom(value).buildPartial();
      } else {
        encryptedDeterministicSeed_ = value;
      }
      bitField0_ |= 0x00000100;
    }
    /**
     * <pre>
     * Encrypted version of the seed
     * </pre>
     *
     * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
     */
    private void clearEncryptedDeterministicSeed() {  encryptedDeterministicSeed_ = null;
      bitField0_ = (bitField0_ & ~0x00000100);
    }

    public static final int ACCOUNT_PATH_FIELD_NUMBER = 10;
    private com.google.protobuf.Internal.IntList accountPath_;
    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     * @return A list containing the accountPath.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getAccountPathList() {
      return accountPath_;
    }
    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     * @return The count of accountPath.
     */
    @java.lang.Override
    public int getAccountPathCount() {
      return accountPath_.size();
    }
    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The accountPath at the given index.
     */
    @java.lang.Override
    public int getAccountPath(int index) {
      return accountPath_.getInt(index);
    }
    private int accountPathMemoizedSerializedSize = -1;
    private void ensureAccountPathIsMutable() {
      com.google.protobuf.Internal.IntList tmp = accountPath_;
      if (!tmp.isModifiable()) {
        accountPath_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     * @param index The index to set the value at.
     * @param value The accountPath to set.
     */
    private void setAccountPath(
        int index, int value) {
      ensureAccountPathIsMutable();
      accountPath_.setInt(index, value);
    }
    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     * @param value The accountPath to add.
     */
    private void addAccountPath(int value) {
      ensureAccountPathIsMutable();
      accountPath_.addInt(value);
    }
    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     * @param values The accountPath to add.
     */
    private void addAllAccountPath(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureAccountPathIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, accountPath_);
    }
    /**
     * <pre>
     * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
     * </pre>
     *
     * <code>repeated uint32 account_path = 10 [packed = true];</code>
     */
    private void clearAccountPath() {
      accountPath_ = emptyIntList();
    }

    public static final int OUTPUT_SCRIPT_TYPE_FIELD_NUMBER = 11;
    private int outputScriptType_;
    /**
     * <pre>
     * Type of addresses (aka output scripts) to generate for receiving.
     * </pre>
     *
     * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
     * @return Whether the outputScriptType field is set.
     */
    @java.lang.Override
    public boolean hasOutputScriptType() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Type of addresses (aka output scripts) to generate for receiving.
     * </pre>
     *
     * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
     * @return The outputScriptType.
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Key.OutputScriptType getOutputScriptType() {
      org.bitcoinj.wallet.Protos.Key.OutputScriptType result = org.bitcoinj.wallet.Protos.Key.OutputScriptType.forNumber(outputScriptType_);
      return result == null ? org.bitcoinj.wallet.Protos.Key.OutputScriptType.P2PKH : result;
    }
    /**
     * <pre>
     * Type of addresses (aka output scripts) to generate for receiving.
     * </pre>
     *
     * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
     * @param value The outputScriptType to set.
     */
    private void setOutputScriptType(org.bitcoinj.wallet.Protos.Key.OutputScriptType value) {
      outputScriptType_ = value.getNumber();
      bitField0_ |= 0x00000200;
    }
    /**
     * <pre>
     * Type of addresses (aka output scripts) to generate for receiving.
     * </pre>
     *
     * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
     */
    private void clearOutputScriptType() {
      bitField0_ = (bitField0_ & ~0x00000200);
      outputScriptType_ = 1;
    }

    public static org.bitcoinj.wallet.Protos.Key parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Key parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Key parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Key parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Key parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Key parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Key parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Key parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Key parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Key parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Key parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Key parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.Key prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     **
     * A key used to control Bitcoin spending.
     * Either the private key, the public key or both may be present.  It is recommended that
     * if the private key is provided that the public key is provided too because deriving it is slow.
     * If only the public key is provided, the key can only be used to watch the blockchain and verify
     * transactions, and not for spending.
     * </pre>
     *
     * Protobuf type {@code wallet.Key}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.Key, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.Key)
        org.bitcoinj.wallet.Protos.KeyOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.Key.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required .wallet.Key.Type type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <code>required .wallet.Key.Type type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Key.Type getType() {
        return instance.getType();
      }
      /**
       * <code>required .wallet.Key.Type type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.bitcoinj.wallet.Protos.Key.Type value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <code>required .wallet.Key.Type type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <pre>
       * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
       * If the secret is encrypted, or this is a "watching entry" then this is missing.
       * </pre>
       *
       * <code>optional bytes secret_bytes = 2;</code>
       * @return Whether the secretBytes field is set.
       */
      @java.lang.Override
      public boolean hasSecretBytes() {
        return instance.hasSecretBytes();
      }
      /**
       * <pre>
       * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
       * If the secret is encrypted, or this is a "watching entry" then this is missing.
       * </pre>
       *
       * <code>optional bytes secret_bytes = 2;</code>
       * @return The secretBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSecretBytes() {
        return instance.getSecretBytes();
      }
      /**
       * <pre>
       * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
       * If the secret is encrypted, or this is a "watching entry" then this is missing.
       * </pre>
       *
       * <code>optional bytes secret_bytes = 2;</code>
       * @param value The secretBytes to set.
       * @return This builder for chaining.
       */
      public Builder setSecretBytes(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSecretBytes(value);
        return this;
      }
      /**
       * <pre>
       * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
       * If the secret is encrypted, or this is a "watching entry" then this is missing.
       * </pre>
       *
       * <code>optional bytes secret_bytes = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSecretBytes() {
        copyOnWrite();
        instance.clearSecretBytes();
        return this;
      }

      /**
       * <pre>
       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
       */
      @java.lang.Override
      public boolean hasEncryptedData() {
        return instance.hasEncryptedData();
      }
      /**
       * <pre>
       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.EncryptedData getEncryptedData() {
        return instance.getEncryptedData();
      }
      /**
       * <pre>
       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
       */
      public Builder setEncryptedData(org.bitcoinj.wallet.Protos.EncryptedData value) {
        copyOnWrite();
        instance.setEncryptedData(value);
        return this;
        }
      /**
       * <pre>
       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
       */
      public Builder setEncryptedData(
          org.bitcoinj.wallet.Protos.EncryptedData.Builder builderForValue) {
        copyOnWrite();
        instance.setEncryptedData(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
       */
      public Builder mergeEncryptedData(org.bitcoinj.wallet.Protos.EncryptedData value) {
        copyOnWrite();
        instance.mergeEncryptedData(value);
        return this;
      }
      /**
       * <pre>
       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
       */
      public Builder clearEncryptedData() {  copyOnWrite();
        instance.clearEncryptedData();
        return this;
      }

      /**
       * <pre>
       * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
       * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
       * </pre>
       *
       * <code>optional bytes public_key = 3;</code>
       * @return Whether the publicKey field is set.
       */
      @java.lang.Override
      public boolean hasPublicKey() {
        return instance.hasPublicKey();
      }
      /**
       * <pre>
       * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
       * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
       * </pre>
       *
       * <code>optional bytes public_key = 3;</code>
       * @return The publicKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPublicKey() {
        return instance.getPublicKey();
      }
      /**
       * <pre>
       * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
       * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
       * </pre>
       *
       * <code>optional bytes public_key = 3;</code>
       * @param value The publicKey to set.
       * @return This builder for chaining.
       */
      public Builder setPublicKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPublicKey(value);
        return this;
      }
      /**
       * <pre>
       * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
       * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
       * </pre>
       *
       * <code>optional bytes public_key = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPublicKey() {
        copyOnWrite();
        instance.clearPublicKey();
        return this;
      }

      /**
       * <pre>
       * User-provided label associated with the key.
       * </pre>
       *
       * <code>optional string label = 4;</code>
       * @return Whether the label field is set.
       */
      @java.lang.Override
      public boolean hasLabel() {
        return instance.hasLabel();
      }
      /**
       * <pre>
       * User-provided label associated with the key.
       * </pre>
       *
       * <code>optional string label = 4;</code>
       * @return The label.
       */
      @java.lang.Override
      public java.lang.String getLabel() {
        return instance.getLabel();
      }
      /**
       * <pre>
       * User-provided label associated with the key.
       * </pre>
       *
       * <code>optional string label = 4;</code>
       * @return The bytes for label.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLabelBytes() {
        return instance.getLabelBytes();
      }
      /**
       * <pre>
       * User-provided label associated with the key.
       * </pre>
       *
       * <code>optional string label = 4;</code>
       * @param value The label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(
          java.lang.String value) {
        copyOnWrite();
        instance.setLabel(value);
        return this;
      }
      /**
       * <pre>
       * User-provided label associated with the key.
       * </pre>
       *
       * <code>optional string label = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        copyOnWrite();
        instance.clearLabel();
        return this;
      }
      /**
       * <pre>
       * User-provided label associated with the key.
       * </pre>
       *
       * <code>optional string label = 4;</code>
       * @param value The bytes for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabelBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLabelBytes(value);
        return this;
      }

      /**
       * <pre>
       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
       * optional is that keys derived from a parent don't have this data.
       * </pre>
       *
       * <code>optional int64 creation_timestamp = 5;</code>
       * @return Whether the creationTimestamp field is set.
       */
      @java.lang.Override
      public boolean hasCreationTimestamp() {
        return instance.hasCreationTimestamp();
      }
      /**
       * <pre>
       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
       * optional is that keys derived from a parent don't have this data.
       * </pre>
       *
       * <code>optional int64 creation_timestamp = 5;</code>
       * @return The creationTimestamp.
       */
      @java.lang.Override
      public long getCreationTimestamp() {
        return instance.getCreationTimestamp();
      }
      /**
       * <pre>
       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
       * optional is that keys derived from a parent don't have this data.
       * </pre>
       *
       * <code>optional int64 creation_timestamp = 5;</code>
       * @param value The creationTimestamp to set.
       * @return This builder for chaining.
       */
      public Builder setCreationTimestamp(long value) {
        copyOnWrite();
        instance.setCreationTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
       * optional is that keys derived from a parent don't have this data.
       * </pre>
       *
       * <code>optional int64 creation_timestamp = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCreationTimestamp() {
        copyOnWrite();
        instance.clearCreationTimestamp();
        return this;
      }

      /**
       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
       */
      @java.lang.Override
      public boolean hasDeterministicKey() {
        return instance.hasDeterministicKey();
      }
      /**
       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.DeterministicKey getDeterministicKey() {
        return instance.getDeterministicKey();
      }
      /**
       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
       */
      public Builder setDeterministicKey(org.bitcoinj.wallet.Protos.DeterministicKey value) {
        copyOnWrite();
        instance.setDeterministicKey(value);
        return this;
        }
      /**
       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
       */
      public Builder setDeterministicKey(
          org.bitcoinj.wallet.Protos.DeterministicKey.Builder builderForValue) {
        copyOnWrite();
        instance.setDeterministicKey(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
       */
      public Builder mergeDeterministicKey(org.bitcoinj.wallet.Protos.DeterministicKey value) {
        copyOnWrite();
        instance.mergeDeterministicKey(value);
        return this;
      }
      /**
       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
       */
      public Builder clearDeterministicKey() {  copyOnWrite();
        instance.clearDeterministicKey();
        return this;
      }

      /**
       * <pre>
       * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
       * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>optional bytes deterministic_seed = 8;</code>
       * @return Whether the deterministicSeed field is set.
       */
      @java.lang.Override
      public boolean hasDeterministicSeed() {
        return instance.hasDeterministicSeed();
      }
      /**
       * <pre>
       * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
       * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>optional bytes deterministic_seed = 8;</code>
       * @return The deterministicSeed.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getDeterministicSeed() {
        return instance.getDeterministicSeed();
      }
      /**
       * <pre>
       * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
       * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>optional bytes deterministic_seed = 8;</code>
       * @param value The deterministicSeed to set.
       * @return This builder for chaining.
       */
      public Builder setDeterministicSeed(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDeterministicSeed(value);
        return this;
      }
      /**
       * <pre>
       * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
       * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>optional bytes deterministic_seed = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeterministicSeed() {
        copyOnWrite();
        instance.clearDeterministicSeed();
        return this;
      }

      /**
       * <pre>
       * Encrypted version of the seed
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
       */
      @java.lang.Override
      public boolean hasEncryptedDeterministicSeed() {
        return instance.hasEncryptedDeterministicSeed();
      }
      /**
       * <pre>
       * Encrypted version of the seed
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.EncryptedData getEncryptedDeterministicSeed() {
        return instance.getEncryptedDeterministicSeed();
      }
      /**
       * <pre>
       * Encrypted version of the seed
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
       */
      public Builder setEncryptedDeterministicSeed(org.bitcoinj.wallet.Protos.EncryptedData value) {
        copyOnWrite();
        instance.setEncryptedDeterministicSeed(value);
        return this;
        }
      /**
       * <pre>
       * Encrypted version of the seed
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
       */
      public Builder setEncryptedDeterministicSeed(
          org.bitcoinj.wallet.Protos.EncryptedData.Builder builderForValue) {
        copyOnWrite();
        instance.setEncryptedDeterministicSeed(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Encrypted version of the seed
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
       */
      public Builder mergeEncryptedDeterministicSeed(org.bitcoinj.wallet.Protos.EncryptedData value) {
        copyOnWrite();
        instance.mergeEncryptedDeterministicSeed(value);
        return this;
      }
      /**
       * <pre>
       * Encrypted version of the seed
       * </pre>
       *
       * <code>optional .wallet.EncryptedData encrypted_deterministic_seed = 9;</code>
       */
      public Builder clearEncryptedDeterministicSeed() {  copyOnWrite();
        instance.clearEncryptedDeterministicSeed();
        return this;
      }

      /**
       * <pre>
       * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>repeated uint32 account_path = 10 [packed = true];</code>
       * @return A list containing the accountPath.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getAccountPathList() {
        return java.util.Collections.unmodifiableList(
            instance.getAccountPathList());
      }
      /**
       * <pre>
       * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>repeated uint32 account_path = 10 [packed = true];</code>
       * @return The count of accountPath.
       */
      @java.lang.Override
      public int getAccountPathCount() {
        return instance.getAccountPathCount();
      }
      /**
       * <pre>
       * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>repeated uint32 account_path = 10 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The accountPath at the given index.
       */
      @java.lang.Override
      public int getAccountPath(int index) {
        return instance.getAccountPath(index);
      }
      /**
       * <pre>
       * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>repeated uint32 account_path = 10 [packed = true];</code>
       * @param value The accountPath to set.
       * @return This builder for chaining.
       */
      public Builder setAccountPath(
          int index, int value) {
        copyOnWrite();
        instance.setAccountPath(index, value);
        return this;
      }
      /**
       * <pre>
       * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>repeated uint32 account_path = 10 [packed = true];</code>
       * @param value The accountPath to add.
       * @return This builder for chaining.
       */
      public Builder addAccountPath(int value) {
        copyOnWrite();
        instance.addAccountPath(value);
        return this;
      }
      /**
       * <pre>
       * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>repeated uint32 account_path = 10 [packed = true];</code>
       * @param values The accountPath to add.
       * @return This builder for chaining.
       */
      public Builder addAllAccountPath(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllAccountPath(values);
        return this;
      }
      /**
       * <pre>
       * The path to the root. Only applicable to a DETERMINISTIC_MNEMONIC key entry.
       * </pre>
       *
       * <code>repeated uint32 account_path = 10 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearAccountPath() {
        copyOnWrite();
        instance.clearAccountPath();
        return this;
      }

      /**
       * <pre>
       * Type of addresses (aka output scripts) to generate for receiving.
       * </pre>
       *
       * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
       * @return Whether the outputScriptType field is set.
       */
      @java.lang.Override
      public boolean hasOutputScriptType() {
        return instance.hasOutputScriptType();
      }
      /**
       * <pre>
       * Type of addresses (aka output scripts) to generate for receiving.
       * </pre>
       *
       * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
       * @return The outputScriptType.
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Key.OutputScriptType getOutputScriptType() {
        return instance.getOutputScriptType();
      }
      /**
       * <pre>
       * Type of addresses (aka output scripts) to generate for receiving.
       * </pre>
       *
       * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
       * @param value The enum numeric value on the wire for outputScriptType to set.
       * @return This builder for chaining.
       */
      public Builder setOutputScriptType(org.bitcoinj.wallet.Protos.Key.OutputScriptType value) {
        copyOnWrite();
        instance.setOutputScriptType(value);
        return this;
      }
      /**
       * <pre>
       * Type of addresses (aka output scripts) to generate for receiving.
       * </pre>
       *
       * <code>optional .wallet.Key.OutputScriptType output_script_type = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutputScriptType() {
        copyOnWrite();
        instance.clearOutputScriptType();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.Key)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.Key();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "type_",
              org.bitcoinj.wallet.Protos.Key.Type.internalGetVerifier(),
              "secretBytes_",
              "publicKey_",
              "label_",
              "creationTimestamp_",
              "encryptedData_",
              "deterministicKey_",
              "deterministicSeed_",
              "encryptedDeterministicSeed_",
              "accountPath_",
              "outputScriptType_",
              org.bitcoinj.wallet.Protos.Key.OutputScriptType.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\u000b\u0000\u0001\u0001\u000b\u000b\u0000\u0001\u0004\u0001\u150c\u0000\u0002" +
                "\u100a\u0001\u0003\u100a\u0003\u0004\u1008\u0004\u0005\u1002\u0005\u0006\u1409\u0002" +
                "\u0007\u1409\u0006\b\u100a\u0007\t\u1409\b\n+\u000b\u100c\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.Key> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.Key.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.Key>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.Key)
    private static final org.bitcoinj.wallet.Protos.Key DEFAULT_INSTANCE;
    static {
      Key defaultInstance = new Key();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Key.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.Key getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Key> PARSER;

    public static com.google.protobuf.Parser<Key> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ScriptOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.Script)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required bytes program = 1;</code>
     * @return Whether the program field is set.
     */
    boolean hasProgram();
    /**
     * <code>required bytes program = 1;</code>
     * @return The program.
     */
    com.google.protobuf.ByteString getProgram();

    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
     * when watching for scripts on the blockchain.
     * </pre>
     *
     * <code>required int64 creation_timestamp = 2;</code>
     * @return Whether the creationTimestamp field is set.
     */
    boolean hasCreationTimestamp();
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
     * when watching for scripts on the blockchain.
     * </pre>
     *
     * <code>required int64 creation_timestamp = 2;</code>
     * @return The creationTimestamp.
     */
    long getCreationTimestamp();
  }
  /**
   * Protobuf type {@code wallet.Script}
   */
  public  static final class Script extends
      com.google.protobuf.GeneratedMessageLite<
          Script, Script.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.Script)
      ScriptOrBuilder {
    private Script() {
      program_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int PROGRAM_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString program_;
    /**
     * <code>required bytes program = 1;</code>
     * @return Whether the program field is set.
     */
    @java.lang.Override
    public boolean hasProgram() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required bytes program = 1;</code>
     * @return The program.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getProgram() {
      return program_;
    }
    /**
     * <code>required bytes program = 1;</code>
     * @param value The program to set.
     */
    private void setProgram(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      program_ = value;
    }
    /**
     * <code>required bytes program = 1;</code>
     */
    private void clearProgram() {
      bitField0_ = (bitField0_ & ~0x00000001);
      program_ = getDefaultInstance().getProgram();
    }

    public static final int CREATION_TIMESTAMP_FIELD_NUMBER = 2;
    private long creationTimestamp_;
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
     * when watching for scripts on the blockchain.
     * </pre>
     *
     * <code>required int64 creation_timestamp = 2;</code>
     * @return Whether the creationTimestamp field is set.
     */
    @java.lang.Override
    public boolean hasCreationTimestamp() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
     * when watching for scripts on the blockchain.
     * </pre>
     *
     * <code>required int64 creation_timestamp = 2;</code>
     * @return The creationTimestamp.
     */
    @java.lang.Override
    public long getCreationTimestamp() {
      return creationTimestamp_;
    }
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
     * when watching for scripts on the blockchain.
     * </pre>
     *
     * <code>required int64 creation_timestamp = 2;</code>
     * @param value The creationTimestamp to set.
     */
    private void setCreationTimestamp(long value) {
      bitField0_ |= 0x00000002;
      creationTimestamp_ = value;
    }
    /**
     * <pre>
     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
     * when watching for scripts on the blockchain.
     * </pre>
     *
     * <code>required int64 creation_timestamp = 2;</code>
     */
    private void clearCreationTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000002);
      creationTimestamp_ = 0L;
    }

    public static org.bitcoinj.wallet.Protos.Script parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Script parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Script parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Script parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Script parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Script parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Script parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Script parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Script parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Script parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Script parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Script parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.Script prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code wallet.Script}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.Script, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.Script)
        org.bitcoinj.wallet.Protos.ScriptOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.Script.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required bytes program = 1;</code>
       * @return Whether the program field is set.
       */
      @java.lang.Override
      public boolean hasProgram() {
        return instance.hasProgram();
      }
      /**
       * <code>required bytes program = 1;</code>
       * @return The program.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getProgram() {
        return instance.getProgram();
      }
      /**
       * <code>required bytes program = 1;</code>
       * @param value The program to set.
       * @return This builder for chaining.
       */
      public Builder setProgram(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setProgram(value);
        return this;
      }
      /**
       * <code>required bytes program = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearProgram() {
        copyOnWrite();
        instance.clearProgram();
        return this;
      }

      /**
       * <pre>
       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
       * when watching for scripts on the blockchain.
       * </pre>
       *
       * <code>required int64 creation_timestamp = 2;</code>
       * @return Whether the creationTimestamp field is set.
       */
      @java.lang.Override
      public boolean hasCreationTimestamp() {
        return instance.hasCreationTimestamp();
      }
      /**
       * <pre>
       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
       * when watching for scripts on the blockchain.
       * </pre>
       *
       * <code>required int64 creation_timestamp = 2;</code>
       * @return The creationTimestamp.
       */
      @java.lang.Override
      public long getCreationTimestamp() {
        return instance.getCreationTimestamp();
      }
      /**
       * <pre>
       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
       * when watching for scripts on the blockchain.
       * </pre>
       *
       * <code>required int64 creation_timestamp = 2;</code>
       * @param value The creationTimestamp to set.
       * @return This builder for chaining.
       */
      public Builder setCreationTimestamp(long value) {
        copyOnWrite();
        instance.setCreationTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
       * when watching for scripts on the blockchain.
       * </pre>
       *
       * <code>required int64 creation_timestamp = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearCreationTimestamp() {
        copyOnWrite();
        instance.clearCreationTimestamp();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.Script)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.Script();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "program_",
              "creationTimestamp_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0002\u0001\u150a\u0000\u0002" +
                "\u1502\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.Script> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.Script.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.Script>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.Script)
    private static final org.bitcoinj.wallet.Protos.Script DEFAULT_INSTANCE;
    static {
      Script defaultInstance = new Script();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Script.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.Script getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Script> PARSER;

    public static com.google.protobuf.Parser<Script> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ScriptWitnessOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.ScriptWitness)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated bytes data = 1;</code>
     * @return A list containing the data.
     */
    java.util.List<com.google.protobuf.ByteString> getDataList();
    /**
     * <code>repeated bytes data = 1;</code>
     * @return The count of data.
     */
    int getDataCount();
    /**
     * <code>repeated bytes data = 1;</code>
     * @param index The index of the element to return.
     * @return The data at the given index.
     */
    com.google.protobuf.ByteString getData(int index);
  }
  /**
   * Protobuf type {@code wallet.ScriptWitness}
   */
  public  static final class ScriptWitness extends
      com.google.protobuf.GeneratedMessageLite<
          ScriptWitness, ScriptWitness.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.ScriptWitness)
      ScriptWitnessOrBuilder {
    private ScriptWitness() {
      data_ = emptyProtobufList();
    }
    public static final int DATA_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> data_;
    /**
     * <code>repeated bytes data = 1;</code>
     * @return A list containing the data.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getDataList() {
      return data_;
    }
    /**
     * <code>repeated bytes data = 1;</code>
     * @return The count of data.
     */
    @java.lang.Override
    public int getDataCount() {
      return data_.size();
    }
    /**
     * <code>repeated bytes data = 1;</code>
     * @param index The index of the element to return.
     * @return The data at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getData(int index) {
      return data_.get(index);
    }
    private void ensureDataIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> tmp = data_;
      if (!tmp.isModifiable()) {
        data_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <code>repeated bytes data = 1;</code>
     * @param index The index to set the value at.
     * @param value The data to set.
     */
    private void setData(
        int index, com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureDataIsMutable();
      data_.set(index, value);
    }
    /**
     * <code>repeated bytes data = 1;</code>
     * @param value The data to add.
     */
    private void addData(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureDataIsMutable();
      data_.add(value);
    }
    /**
     * <code>repeated bytes data = 1;</code>
     * @param values The data to add.
     */
    private void addAllData(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      ensureDataIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, data_);
    }
    /**
     * <code>repeated bytes data = 1;</code>
     */
    private void clearData() {
      data_ = emptyProtobufList();
    }

    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.ScriptWitness parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.ScriptWitness prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code wallet.ScriptWitness}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.ScriptWitness, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.ScriptWitness)
        org.bitcoinj.wallet.Protos.ScriptWitnessOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.ScriptWitness.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated bytes data = 1;</code>
       * @return A list containing the data.
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.ByteString>
          getDataList() {
        return java.util.Collections.unmodifiableList(
            instance.getDataList());
      }
      /**
       * <code>repeated bytes data = 1;</code>
       * @return The count of data.
       */
      @java.lang.Override
      public int getDataCount() {
        return instance.getDataCount();
      }
      /**
       * <code>repeated bytes data = 1;</code>
       * @param index The index of the element to return.
       * @return The data at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getData(int index) {
        return instance.getData(index);
      }
      /**
       * <code>repeated bytes data = 1;</code>
       * @param value The data to set.
       * @return This builder for chaining.
       */
      public Builder setData(
          int index, com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setData(index, value);
        return this;
      }
      /**
       * <code>repeated bytes data = 1;</code>
       * @param value The data to add.
       * @return This builder for chaining.
       */
      public Builder addData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addData(value);
        return this;
      }
      /**
       * <code>repeated bytes data = 1;</code>
       * @param values The data to add.
       * @return This builder for chaining.
       */
      public Builder addAllData(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.addAllData(values);
        return this;
      }
      /**
       * <code>repeated bytes data = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearData() {
        copyOnWrite();
        instance.clearData();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.ScriptWitness)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.ScriptWitness();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "data_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001c";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.ScriptWitness> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.ScriptWitness.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.ScriptWitness>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.ScriptWitness)
    private static final org.bitcoinj.wallet.Protos.ScriptWitness DEFAULT_INSTANCE;
    static {
      ScriptWitness defaultInstance = new ScriptWitness();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ScriptWitness.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.ScriptWitness getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ScriptWitness> PARSER;

    public static com.google.protobuf.Parser<ScriptWitness> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TransactionInputOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.TransactionInput)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Hash of the transaction this input is using.
     * </pre>
     *
     * <code>required bytes transaction_out_point_hash = 1;</code>
     * @return Whether the transactionOutPointHash field is set.
     */
    boolean hasTransactionOutPointHash();
    /**
     * <pre>
     * Hash of the transaction this input is using.
     * </pre>
     *
     * <code>required bytes transaction_out_point_hash = 1;</code>
     * @return The transactionOutPointHash.
     */
    com.google.protobuf.ByteString getTransactionOutPointHash();

    /**
     * <pre>
     * Index of transaction output used by this input.
     * </pre>
     *
     * <code>required uint32 transaction_out_point_index = 2;</code>
     * @return Whether the transactionOutPointIndex field is set.
     */
    boolean hasTransactionOutPointIndex();
    /**
     * <pre>
     * Index of transaction output used by this input.
     * </pre>
     *
     * <code>required uint32 transaction_out_point_index = 2;</code>
     * @return The transactionOutPointIndex.
     */
    int getTransactionOutPointIndex();

    /**
     * <pre>
     * Script that contains the signatures/pubkeys.
     * </pre>
     *
     * <code>required bytes script_bytes = 3;</code>
     * @return Whether the scriptBytes field is set.
     */
    boolean hasScriptBytes();
    /**
     * <pre>
     * Script that contains the signatures/pubkeys.
     * </pre>
     *
     * <code>required bytes script_bytes = 3;</code>
     * @return The scriptBytes.
     */
    com.google.protobuf.ByteString getScriptBytes();

    /**
     * <pre>
     * Sequence number.
     * </pre>
     *
     * <code>optional uint32 sequence = 4;</code>
     * @return Whether the sequence field is set.
     */
    boolean hasSequence();
    /**
     * <pre>
     * Sequence number.
     * </pre>
     *
     * <code>optional uint32 sequence = 4;</code>
     * @return The sequence.
     */
    int getSequence();

    /**
     * <pre>
     * Value of connected output, if known
     * </pre>
     *
     * <code>optional int64 value = 5;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * Value of connected output, if known
     * </pre>
     *
     * <code>optional int64 value = 5;</code>
     * @return The value.
     */
    long getValue();

    /**
     * <pre>
     * script witness
     * </pre>
     *
     * <code>optional .wallet.ScriptWitness witness = 6;</code>
     * @return Whether the witness field is set.
     */
    boolean hasWitness();
    /**
     * <pre>
     * script witness
     * </pre>
     *
     * <code>optional .wallet.ScriptWitness witness = 6;</code>
     * @return The witness.
     */
    org.bitcoinj.wallet.Protos.ScriptWitness getWitness();
  }
  /**
   * Protobuf type {@code wallet.TransactionInput}
   */
  public  static final class TransactionInput extends
      com.google.protobuf.GeneratedMessageLite<
          TransactionInput, TransactionInput.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.TransactionInput)
      TransactionInputOrBuilder {
    private TransactionInput() {
      transactionOutPointHash_ = com.google.protobuf.ByteString.EMPTY;
      scriptBytes_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int TRANSACTION_OUT_POINT_HASH_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString transactionOutPointHash_;
    /**
     * <pre>
     * Hash of the transaction this input is using.
     * </pre>
     *
     * <code>required bytes transaction_out_point_hash = 1;</code>
     * @return Whether the transactionOutPointHash field is set.
     */
    @java.lang.Override
    public boolean hasTransactionOutPointHash() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Hash of the transaction this input is using.
     * </pre>
     *
     * <code>required bytes transaction_out_point_hash = 1;</code>
     * @return The transactionOutPointHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTransactionOutPointHash() {
      return transactionOutPointHash_;
    }
    /**
     * <pre>
     * Hash of the transaction this input is using.
     * </pre>
     *
     * <code>required bytes transaction_out_point_hash = 1;</code>
     * @param value The transactionOutPointHash to set.
     */
    private void setTransactionOutPointHash(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      transactionOutPointHash_ = value;
    }
    /**
     * <pre>
     * Hash of the transaction this input is using.
     * </pre>
     *
     * <code>required bytes transaction_out_point_hash = 1;</code>
     */
    private void clearTransactionOutPointHash() {
      bitField0_ = (bitField0_ & ~0x00000001);
      transactionOutPointHash_ = getDefaultInstance().getTransactionOutPointHash();
    }

    public static final int TRANSACTION_OUT_POINT_INDEX_FIELD_NUMBER = 2;
    private int transactionOutPointIndex_;
    /**
     * <pre>
     * Index of transaction output used by this input.
     * </pre>
     *
     * <code>required uint32 transaction_out_point_index = 2;</code>
     * @return Whether the transactionOutPointIndex field is set.
     */
    @java.lang.Override
    public boolean hasTransactionOutPointIndex() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Index of transaction output used by this input.
     * </pre>
     *
     * <code>required uint32 transaction_out_point_index = 2;</code>
     * @return The transactionOutPointIndex.
     */
    @java.lang.Override
    public int getTransactionOutPointIndex() {
      return transactionOutPointIndex_;
    }
    /**
     * <pre>
     * Index of transaction output used by this input.
     * </pre>
     *
     * <code>required uint32 transaction_out_point_index = 2;</code>
     * @param value The transactionOutPointIndex to set.
     */
    private void setTransactionOutPointIndex(int value) {
      bitField0_ |= 0x00000002;
      transactionOutPointIndex_ = value;
    }
    /**
     * <pre>
     * Index of transaction output used by this input.
     * </pre>
     *
     * <code>required uint32 transaction_out_point_index = 2;</code>
     */
    private void clearTransactionOutPointIndex() {
      bitField0_ = (bitField0_ & ~0x00000002);
      transactionOutPointIndex_ = 0;
    }

    public static final int SCRIPT_BYTES_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString scriptBytes_;
    /**
     * <pre>
     * Script that contains the signatures/pubkeys.
     * </pre>
     *
     * <code>required bytes script_bytes = 3;</code>
     * @return Whether the scriptBytes field is set.
     */
    @java.lang.Override
    public boolean hasScriptBytes() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Script that contains the signatures/pubkeys.
     * </pre>
     *
     * <code>required bytes script_bytes = 3;</code>
     * @return The scriptBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getScriptBytes() {
      return scriptBytes_;
    }
    /**
     * <pre>
     * Script that contains the signatures/pubkeys.
     * </pre>
     *
     * <code>required bytes script_bytes = 3;</code>
     * @param value The scriptBytes to set.
     */
    private void setScriptBytes(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      scriptBytes_ = value;
    }
    /**
     * <pre>
     * Script that contains the signatures/pubkeys.
     * </pre>
     *
     * <code>required bytes script_bytes = 3;</code>
     */
    private void clearScriptBytes() {
      bitField0_ = (bitField0_ & ~0x00000004);
      scriptBytes_ = getDefaultInstance().getScriptBytes();
    }

    public static final int SEQUENCE_FIELD_NUMBER = 4;
    private int sequence_;
    /**
     * <pre>
     * Sequence number.
     * </pre>
     *
     * <code>optional uint32 sequence = 4;</code>
     * @return Whether the sequence field is set.
     */
    @java.lang.Override
    public boolean hasSequence() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Sequence number.
     * </pre>
     *
     * <code>optional uint32 sequence = 4;</code>
     * @return The sequence.
     */
    @java.lang.Override
    public int getSequence() {
      return sequence_;
    }
    /**
     * <pre>
     * Sequence number.
     * </pre>
     *
     * <code>optional uint32 sequence = 4;</code>
     * @param value The sequence to set.
     */
    private void setSequence(int value) {
      bitField0_ |= 0x00000008;
      sequence_ = value;
    }
    /**
     * <pre>
     * Sequence number.
     * </pre>
     *
     * <code>optional uint32 sequence = 4;</code>
     */
    private void clearSequence() {
      bitField0_ = (bitField0_ & ~0x00000008);
      sequence_ = 0;
    }

    public static final int VALUE_FIELD_NUMBER = 5;
    private long value_;
    /**
     * <pre>
     * Value of connected output, if known
     * </pre>
     *
     * <code>optional int64 value = 5;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Value of connected output, if known
     * </pre>
     *
     * <code>optional int64 value = 5;</code>
     * @return The value.
     */
    @java.lang.Override
    public long getValue() {
      return value_;
    }
    /**
     * <pre>
     * Value of connected output, if known
     * </pre>
     *
     * <code>optional int64 value = 5;</code>
     * @param value The value to set.
     */
    private void setValue(long value) {
      bitField0_ |= 0x00000010;
      value_ = value;
    }
    /**
     * <pre>
     * Value of connected output, if known
     * </pre>
     *
     * <code>optional int64 value = 5;</code>
     */
    private void clearValue() {
      bitField0_ = (bitField0_ & ~0x00000010);
      value_ = 0L;
    }

    public static final int WITNESS_FIELD_NUMBER = 6;
    private org.bitcoinj.wallet.Protos.ScriptWitness witness_;
    /**
     * <pre>
     * script witness
     * </pre>
     *
     * <code>optional .wallet.ScriptWitness witness = 6;</code>
     */
    @java.lang.Override
    public boolean hasWitness() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * script witness
     * </pre>
     *
     * <code>optional .wallet.ScriptWitness witness = 6;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.ScriptWitness getWitness() {
      return witness_ == null ? org.bitcoinj.wallet.Protos.ScriptWitness.getDefaultInstance() : witness_;
    }
    /**
     * <pre>
     * script witness
     * </pre>
     *
     * <code>optional .wallet.ScriptWitness witness = 6;</code>
     */
    private void setWitness(org.bitcoinj.wallet.Protos.ScriptWitness value) {
      value.getClass();
  witness_ = value;
      bitField0_ |= 0x00000020;
      }
    /**
     * <pre>
     * script witness
     * </pre>
     *
     * <code>optional .wallet.ScriptWitness witness = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeWitness(org.bitcoinj.wallet.Protos.ScriptWitness value) {
      value.getClass();
  if (witness_ != null &&
          witness_ != org.bitcoinj.wallet.Protos.ScriptWitness.getDefaultInstance()) {
        witness_ =
          org.bitcoinj.wallet.Protos.ScriptWitness.newBuilder(witness_).mergeFrom(value).buildPartial();
      } else {
        witness_ = value;
      }
      bitField0_ |= 0x00000020;
    }
    /**
     * <pre>
     * script witness
     * </pre>
     *
     * <code>optional .wallet.ScriptWitness witness = 6;</code>
     */
    private void clearWitness() {  witness_ = null;
      bitField0_ = (bitField0_ & ~0x00000020);
    }

    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.TransactionInput parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.TransactionInput prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code wallet.TransactionInput}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.TransactionInput, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.TransactionInput)
        org.bitcoinj.wallet.Protos.TransactionInputOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.TransactionInput.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Hash of the transaction this input is using.
       * </pre>
       *
       * <code>required bytes transaction_out_point_hash = 1;</code>
       * @return Whether the transactionOutPointHash field is set.
       */
      @java.lang.Override
      public boolean hasTransactionOutPointHash() {
        return instance.hasTransactionOutPointHash();
      }
      /**
       * <pre>
       * Hash of the transaction this input is using.
       * </pre>
       *
       * <code>required bytes transaction_out_point_hash = 1;</code>
       * @return The transactionOutPointHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTransactionOutPointHash() {
        return instance.getTransactionOutPointHash();
      }
      /**
       * <pre>
       * Hash of the transaction this input is using.
       * </pre>
       *
       * <code>required bytes transaction_out_point_hash = 1;</code>
       * @param value The transactionOutPointHash to set.
       * @return This builder for chaining.
       */
      public Builder setTransactionOutPointHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTransactionOutPointHash(value);
        return this;
      }
      /**
       * <pre>
       * Hash of the transaction this input is using.
       * </pre>
       *
       * <code>required bytes transaction_out_point_hash = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTransactionOutPointHash() {
        copyOnWrite();
        instance.clearTransactionOutPointHash();
        return this;
      }

      /**
       * <pre>
       * Index of transaction output used by this input.
       * </pre>
       *
       * <code>required uint32 transaction_out_point_index = 2;</code>
       * @return Whether the transactionOutPointIndex field is set.
       */
      @java.lang.Override
      public boolean hasTransactionOutPointIndex() {
        return instance.hasTransactionOutPointIndex();
      }
      /**
       * <pre>
       * Index of transaction output used by this input.
       * </pre>
       *
       * <code>required uint32 transaction_out_point_index = 2;</code>
       * @return The transactionOutPointIndex.
       */
      @java.lang.Override
      public int getTransactionOutPointIndex() {
        return instance.getTransactionOutPointIndex();
      }
      /**
       * <pre>
       * Index of transaction output used by this input.
       * </pre>
       *
       * <code>required uint32 transaction_out_point_index = 2;</code>
       * @param value The transactionOutPointIndex to set.
       * @return This builder for chaining.
       */
      public Builder setTransactionOutPointIndex(int value) {
        copyOnWrite();
        instance.setTransactionOutPointIndex(value);
        return this;
      }
      /**
       * <pre>
       * Index of transaction output used by this input.
       * </pre>
       *
       * <code>required uint32 transaction_out_point_index = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTransactionOutPointIndex() {
        copyOnWrite();
        instance.clearTransactionOutPointIndex();
        return this;
      }

      /**
       * <pre>
       * Script that contains the signatures/pubkeys.
       * </pre>
       *
       * <code>required bytes script_bytes = 3;</code>
       * @return Whether the scriptBytes field is set.
       */
      @java.lang.Override
      public boolean hasScriptBytes() {
        return instance.hasScriptBytes();
      }
      /**
       * <pre>
       * Script that contains the signatures/pubkeys.
       * </pre>
       *
       * <code>required bytes script_bytes = 3;</code>
       * @return The scriptBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getScriptBytes() {
        return instance.getScriptBytes();
      }
      /**
       * <pre>
       * Script that contains the signatures/pubkeys.
       * </pre>
       *
       * <code>required bytes script_bytes = 3;</code>
       * @param value The scriptBytes to set.
       * @return This builder for chaining.
       */
      public Builder setScriptBytes(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setScriptBytes(value);
        return this;
      }
      /**
       * <pre>
       * Script that contains the signatures/pubkeys.
       * </pre>
       *
       * <code>required bytes script_bytes = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearScriptBytes() {
        copyOnWrite();
        instance.clearScriptBytes();
        return this;
      }

      /**
       * <pre>
       * Sequence number.
       * </pre>
       *
       * <code>optional uint32 sequence = 4;</code>
       * @return Whether the sequence field is set.
       */
      @java.lang.Override
      public boolean hasSequence() {
        return instance.hasSequence();
      }
      /**
       * <pre>
       * Sequence number.
       * </pre>
       *
       * <code>optional uint32 sequence = 4;</code>
       * @return The sequence.
       */
      @java.lang.Override
      public int getSequence() {
        return instance.getSequence();
      }
      /**
       * <pre>
       * Sequence number.
       * </pre>
       *
       * <code>optional uint32 sequence = 4;</code>
       * @param value The sequence to set.
       * @return This builder for chaining.
       */
      public Builder setSequence(int value) {
        copyOnWrite();
        instance.setSequence(value);
        return this;
      }
      /**
       * <pre>
       * Sequence number.
       * </pre>
       *
       * <code>optional uint32 sequence = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSequence() {
        copyOnWrite();
        instance.clearSequence();
        return this;
      }

      /**
       * <pre>
       * Value of connected output, if known
       * </pre>
       *
       * <code>optional int64 value = 5;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <pre>
       * Value of connected output, if known
       * </pre>
       *
       * <code>optional int64 value = 5;</code>
       * @return The value.
       */
      @java.lang.Override
      public long getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * Value of connected output, if known
       * </pre>
       *
       * <code>optional int64 value = 5;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(long value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <pre>
       * Value of connected output, if known
       * </pre>
       *
       * <code>optional int64 value = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      /**
       * <pre>
       * script witness
       * </pre>
       *
       * <code>optional .wallet.ScriptWitness witness = 6;</code>
       */
      @java.lang.Override
      public boolean hasWitness() {
        return instance.hasWitness();
      }
      /**
       * <pre>
       * script witness
       * </pre>
       *
       * <code>optional .wallet.ScriptWitness witness = 6;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.ScriptWitness getWitness() {
        return instance.getWitness();
      }
      /**
       * <pre>
       * script witness
       * </pre>
       *
       * <code>optional .wallet.ScriptWitness witness = 6;</code>
       */
      public Builder setWitness(org.bitcoinj.wallet.Protos.ScriptWitness value) {
        copyOnWrite();
        instance.setWitness(value);
        return this;
        }
      /**
       * <pre>
       * script witness
       * </pre>
       *
       * <code>optional .wallet.ScriptWitness witness = 6;</code>
       */
      public Builder setWitness(
          org.bitcoinj.wallet.Protos.ScriptWitness.Builder builderForValue) {
        copyOnWrite();
        instance.setWitness(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * script witness
       * </pre>
       *
       * <code>optional .wallet.ScriptWitness witness = 6;</code>
       */
      public Builder mergeWitness(org.bitcoinj.wallet.Protos.ScriptWitness value) {
        copyOnWrite();
        instance.mergeWitness(value);
        return this;
      }
      /**
       * <pre>
       * script witness
       * </pre>
       *
       * <code>optional .wallet.ScriptWitness witness = 6;</code>
       */
      public Builder clearWitness() {  copyOnWrite();
        instance.clearWitness();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.TransactionInput)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.TransactionInput();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "transactionOutPointHash_",
              "transactionOutPointIndex_",
              "scriptBytes_",
              "sequence_",
              "value_",
              "witness_",
            };
            java.lang.String info =
                "\u0001\u0006\u0000\u0001\u0001\u0006\u0006\u0000\u0000\u0003\u0001\u150a\u0000\u0002" +
                "\u150b\u0001\u0003\u150a\u0002\u0004\u100b\u0003\u0005\u1002\u0004\u0006\u1009\u0005" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.TransactionInput> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.TransactionInput.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.TransactionInput>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.TransactionInput)
    private static final org.bitcoinj.wallet.Protos.TransactionInput DEFAULT_INSTANCE;
    static {
      TransactionInput defaultInstance = new TransactionInput();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TransactionInput.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.TransactionInput getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TransactionInput> PARSER;

    public static com.google.protobuf.Parser<TransactionInput> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TransactionOutputOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.TransactionOutput)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required int64 value = 1;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <code>required int64 value = 1;</code>
     * @return The value.
     */
    long getValue();

    /**
     * <pre>
     * script of transaction output
     * </pre>
     *
     * <code>required bytes script_bytes = 2;</code>
     * @return Whether the scriptBytes field is set.
     */
    boolean hasScriptBytes();
    /**
     * <pre>
     * script of transaction output
     * </pre>
     *
     * <code>required bytes script_bytes = 2;</code>
     * @return The scriptBytes.
     */
    com.google.protobuf.ByteString getScriptBytes();

    /**
     * <pre>
     * If spent, the hash of the transaction doing the spend.
     * </pre>
     *
     * <code>optional bytes spent_by_transaction_hash = 3;</code>
     * @return Whether the spentByTransactionHash field is set.
     */
    boolean hasSpentByTransactionHash();
    /**
     * <pre>
     * If spent, the hash of the transaction doing the spend.
     * </pre>
     *
     * <code>optional bytes spent_by_transaction_hash = 3;</code>
     * @return The spentByTransactionHash.
     */
    com.google.protobuf.ByteString getSpentByTransactionHash();

    /**
     * <pre>
     * If spent, the index of the transaction input of the transaction doing the spend.
     * </pre>
     *
     * <code>optional int32 spent_by_transaction_index = 4;</code>
     * @return Whether the spentByTransactionIndex field is set.
     */
    boolean hasSpentByTransactionIndex();
    /**
     * <pre>
     * If spent, the index of the transaction input of the transaction doing the spend.
     * </pre>
     *
     * <code>optional int32 spent_by_transaction_index = 4;</code>
     * @return The spentByTransactionIndex.
     */
    int getSpentByTransactionIndex();
  }
  /**
   * Protobuf type {@code wallet.TransactionOutput}
   */
  public  static final class TransactionOutput extends
      com.google.protobuf.GeneratedMessageLite<
          TransactionOutput, TransactionOutput.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.TransactionOutput)
      TransactionOutputOrBuilder {
    private TransactionOutput() {
      scriptBytes_ = com.google.protobuf.ByteString.EMPTY;
      spentByTransactionHash_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int VALUE_FIELD_NUMBER = 1;
    private long value_;
    /**
     * <code>required int64 value = 1;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required int64 value = 1;</code>
     * @return The value.
     */
    @java.lang.Override
    public long getValue() {
      return value_;
    }
    /**
     * <code>required int64 value = 1;</code>
     * @param value The value to set.
     */
    private void setValue(long value) {
      bitField0_ |= 0x00000001;
      value_ = value;
    }
    /**
     * <code>required int64 value = 1;</code>
     */
    private void clearValue() {
      bitField0_ = (bitField0_ & ~0x00000001);
      value_ = 0L;
    }

    public static final int SCRIPT_BYTES_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString scriptBytes_;
    /**
     * <pre>
     * script of transaction output
     * </pre>
     *
     * <code>required bytes script_bytes = 2;</code>
     * @return Whether the scriptBytes field is set.
     */
    @java.lang.Override
    public boolean hasScriptBytes() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * script of transaction output
     * </pre>
     *
     * <code>required bytes script_bytes = 2;</code>
     * @return The scriptBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getScriptBytes() {
      return scriptBytes_;
    }
    /**
     * <pre>
     * script of transaction output
     * </pre>
     *
     * <code>required bytes script_bytes = 2;</code>
     * @param value The scriptBytes to set.
     */
    private void setScriptBytes(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      scriptBytes_ = value;
    }
    /**
     * <pre>
     * script of transaction output
     * </pre>
     *
     * <code>required bytes script_bytes = 2;</code>
     */
    private void clearScriptBytes() {
      bitField0_ = (bitField0_ & ~0x00000002);
      scriptBytes_ = getDefaultInstance().getScriptBytes();
    }

    public static final int SPENT_BY_TRANSACTION_HASH_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString spentByTransactionHash_;
    /**
     * <pre>
     * If spent, the hash of the transaction doing the spend.
     * </pre>
     *
     * <code>optional bytes spent_by_transaction_hash = 3;</code>
     * @return Whether the spentByTransactionHash field is set.
     */
    @java.lang.Override
    public boolean hasSpentByTransactionHash() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If spent, the hash of the transaction doing the spend.
     * </pre>
     *
     * <code>optional bytes spent_by_transaction_hash = 3;</code>
     * @return The spentByTransactionHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSpentByTransactionHash() {
      return spentByTransactionHash_;
    }
    /**
     * <pre>
     * If spent, the hash of the transaction doing the spend.
     * </pre>
     *
     * <code>optional bytes spent_by_transaction_hash = 3;</code>
     * @param value The spentByTransactionHash to set.
     */
    private void setSpentByTransactionHash(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      spentByTransactionHash_ = value;
    }
    /**
     * <pre>
     * If spent, the hash of the transaction doing the spend.
     * </pre>
     *
     * <code>optional bytes spent_by_transaction_hash = 3;</code>
     */
    private void clearSpentByTransactionHash() {
      bitField0_ = (bitField0_ & ~0x00000004);
      spentByTransactionHash_ = getDefaultInstance().getSpentByTransactionHash();
    }

    public static final int SPENT_BY_TRANSACTION_INDEX_FIELD_NUMBER = 4;
    private int spentByTransactionIndex_;
    /**
     * <pre>
     * If spent, the index of the transaction input of the transaction doing the spend.
     * </pre>
     *
     * <code>optional int32 spent_by_transaction_index = 4;</code>
     * @return Whether the spentByTransactionIndex field is set.
     */
    @java.lang.Override
    public boolean hasSpentByTransactionIndex() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If spent, the index of the transaction input of the transaction doing the spend.
     * </pre>
     *
     * <code>optional int32 spent_by_transaction_index = 4;</code>
     * @return The spentByTransactionIndex.
     */
    @java.lang.Override
    public int getSpentByTransactionIndex() {
      return spentByTransactionIndex_;
    }
    /**
     * <pre>
     * If spent, the index of the transaction input of the transaction doing the spend.
     * </pre>
     *
     * <code>optional int32 spent_by_transaction_index = 4;</code>
     * @param value The spentByTransactionIndex to set.
     */
    private void setSpentByTransactionIndex(int value) {
      bitField0_ |= 0x00000008;
      spentByTransactionIndex_ = value;
    }
    /**
     * <pre>
     * If spent, the index of the transaction input of the transaction doing the spend.
     * </pre>
     *
     * <code>optional int32 spent_by_transaction_index = 4;</code>
     */
    private void clearSpentByTransactionIndex() {
      bitField0_ = (bitField0_ & ~0x00000008);
      spentByTransactionIndex_ = 0;
    }

    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.TransactionOutput parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.TransactionOutput prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code wallet.TransactionOutput}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.TransactionOutput, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.TransactionOutput)
        org.bitcoinj.wallet.Protos.TransactionOutputOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.TransactionOutput.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required int64 value = 1;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <code>required int64 value = 1;</code>
       * @return The value.
       */
      @java.lang.Override
      public long getValue() {
        return instance.getValue();
      }
      /**
       * <code>required int64 value = 1;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(long value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <code>required int64 value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      /**
       * <pre>
       * script of transaction output
       * </pre>
       *
       * <code>required bytes script_bytes = 2;</code>
       * @return Whether the scriptBytes field is set.
       */
      @java.lang.Override
      public boolean hasScriptBytes() {
        return instance.hasScriptBytes();
      }
      /**
       * <pre>
       * script of transaction output
       * </pre>
       *
       * <code>required bytes script_bytes = 2;</code>
       * @return The scriptBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getScriptBytes() {
        return instance.getScriptBytes();
      }
      /**
       * <pre>
       * script of transaction output
       * </pre>
       *
       * <code>required bytes script_bytes = 2;</code>
       * @param value The scriptBytes to set.
       * @return This builder for chaining.
       */
      public Builder setScriptBytes(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setScriptBytes(value);
        return this;
      }
      /**
       * <pre>
       * script of transaction output
       * </pre>
       *
       * <code>required bytes script_bytes = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearScriptBytes() {
        copyOnWrite();
        instance.clearScriptBytes();
        return this;
      }

      /**
       * <pre>
       * If spent, the hash of the transaction doing the spend.
       * </pre>
       *
       * <code>optional bytes spent_by_transaction_hash = 3;</code>
       * @return Whether the spentByTransactionHash field is set.
       */
      @java.lang.Override
      public boolean hasSpentByTransactionHash() {
        return instance.hasSpentByTransactionHash();
      }
      /**
       * <pre>
       * If spent, the hash of the transaction doing the spend.
       * </pre>
       *
       * <code>optional bytes spent_by_transaction_hash = 3;</code>
       * @return The spentByTransactionHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSpentByTransactionHash() {
        return instance.getSpentByTransactionHash();
      }
      /**
       * <pre>
       * If spent, the hash of the transaction doing the spend.
       * </pre>
       *
       * <code>optional bytes spent_by_transaction_hash = 3;</code>
       * @param value The spentByTransactionHash to set.
       * @return This builder for chaining.
       */
      public Builder setSpentByTransactionHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSpentByTransactionHash(value);
        return this;
      }
      /**
       * <pre>
       * If spent, the hash of the transaction doing the spend.
       * </pre>
       *
       * <code>optional bytes spent_by_transaction_hash = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpentByTransactionHash() {
        copyOnWrite();
        instance.clearSpentByTransactionHash();
        return this;
      }

      /**
       * <pre>
       * If spent, the index of the transaction input of the transaction doing the spend.
       * </pre>
       *
       * <code>optional int32 spent_by_transaction_index = 4;</code>
       * @return Whether the spentByTransactionIndex field is set.
       */
      @java.lang.Override
      public boolean hasSpentByTransactionIndex() {
        return instance.hasSpentByTransactionIndex();
      }
      /**
       * <pre>
       * If spent, the index of the transaction input of the transaction doing the spend.
       * </pre>
       *
       * <code>optional int32 spent_by_transaction_index = 4;</code>
       * @return The spentByTransactionIndex.
       */
      @java.lang.Override
      public int getSpentByTransactionIndex() {
        return instance.getSpentByTransactionIndex();
      }
      /**
       * <pre>
       * If spent, the index of the transaction input of the transaction doing the spend.
       * </pre>
       *
       * <code>optional int32 spent_by_transaction_index = 4;</code>
       * @param value The spentByTransactionIndex to set.
       * @return This builder for chaining.
       */
      public Builder setSpentByTransactionIndex(int value) {
        copyOnWrite();
        instance.setSpentByTransactionIndex(value);
        return this;
      }
      /**
       * <pre>
       * If spent, the index of the transaction input of the transaction doing the spend.
       * </pre>
       *
       * <code>optional int32 spent_by_transaction_index = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpentByTransactionIndex() {
        copyOnWrite();
        instance.clearSpentByTransactionIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.TransactionOutput)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.TransactionOutput();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "value_",
              "scriptBytes_",
              "spentByTransactionHash_",
              "spentByTransactionIndex_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0000\u0002\u0001\u1502\u0000\u0002" +
                "\u150a\u0001\u0003\u100a\u0002\u0004\u1004\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.TransactionOutput> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.TransactionOutput.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.TransactionOutput>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.TransactionOutput)
    private static final org.bitcoinj.wallet.Protos.TransactionOutput DEFAULT_INSTANCE;
    static {
      TransactionOutput defaultInstance = new TransactionOutput();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TransactionOutput.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.TransactionOutput getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TransactionOutput> PARSER;

    public static com.google.protobuf.Parser<TransactionOutput> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TransactionConfidenceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.TransactionConfidence)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
     * @return The type.
     */
    org.bitcoinj.wallet.Protos.TransactionConfidence.Type getType();

    /**
     * <pre>
     * If type == BUILDING then this is the chain height at which the transaction was included.
     * </pre>
     *
     * <code>optional int32 appeared_at_height = 2;</code>
     * @return Whether the appearedAtHeight field is set.
     */
    boolean hasAppearedAtHeight();
    /**
     * <pre>
     * If type == BUILDING then this is the chain height at which the transaction was included.
     * </pre>
     *
     * <code>optional int32 appeared_at_height = 2;</code>
     * @return The appearedAtHeight.
     */
    int getAppearedAtHeight();

    /**
     * <pre>
     * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
     * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
     * bother to track them all, just the first. This only makes sense if type = DEAD.
     * </pre>
     *
     * <code>optional bytes overriding_transaction = 3;</code>
     * @return Whether the overridingTransaction field is set.
     */
    boolean hasOverridingTransaction();
    /**
     * <pre>
     * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
     * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
     * bother to track them all, just the first. This only makes sense if type = DEAD.
     * </pre>
     *
     * <code>optional bytes overriding_transaction = 3;</code>
     * @return The overridingTransaction.
     */
    com.google.protobuf.ByteString getOverridingTransaction();

    /**
     * <pre>
     * If type == BUILDING then this is the depth of the transaction in the blockchain.
     * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
     * </pre>
     *
     * <code>optional int32 depth = 4;</code>
     * @return Whether the depth field is set.
     */
    boolean hasDepth();
    /**
     * <pre>
     * If type == BUILDING then this is the depth of the transaction in the blockchain.
     * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
     * </pre>
     *
     * <code>optional int32 depth = 4;</code>
     * @return The depth.
     */
    int getDepth();

    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    java.util.List<org.bitcoinj.wallet.Protos.PeerAddress> 
        getBroadcastByList();
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    org.bitcoinj.wallet.Protos.PeerAddress getBroadcastBy(int index);
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    int getBroadcastByCount();

    /**
     * <pre>
     * Millis since epoch the transaction was last announced to us.
     * </pre>
     *
     * <code>optional int64 last_broadcasted_at = 8;</code>
     * @return Whether the lastBroadcastedAt field is set.
     */
    boolean hasLastBroadcastedAt();
    /**
     * <pre>
     * Millis since epoch the transaction was last announced to us.
     * </pre>
     *
     * <code>optional int64 last_broadcasted_at = 8;</code>
     * @return The lastBroadcastedAt.
     */
    long getLastBroadcastedAt();

    /**
     * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
     * @return Whether the source field is set.
     */
    boolean hasSource();
    /**
     * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
     * @return The source.
     */
    org.bitcoinj.wallet.Protos.TransactionConfidence.Source getSource();
  }
  /**
   * <pre>
   **
   * A description of the confidence we have that a transaction cannot be reversed in the future.
   * Parsing should be lenient, since this could change for different applications yet we should
   * maintain backward compatibility.
   * </pre>
   *
   * Protobuf type {@code wallet.TransactionConfidence}
   */
  public  static final class TransactionConfidence extends
      com.google.protobuf.GeneratedMessageLite<
          TransactionConfidence, TransactionConfidence.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.TransactionConfidence)
      TransactionConfidenceOrBuilder {
    private TransactionConfidence() {
      overridingTransaction_ = com.google.protobuf.ByteString.EMPTY;
      broadcastBy_ = emptyProtobufList();
    }
    /**
     * Protobuf enum {@code wallet.TransactionConfidence.Type}
     */
    public enum Type
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * See TransactionConfidence.java for a more thorough explanation of these types.
       * </pre>
       *
       * <code>UNKNOWN = 0;</code>
       */
      UNKNOWN(0),
      /**
       * <pre>
       * In best chain.  If and only if appeared_at_height is present.
       * </pre>
       *
       * <code>BUILDING = 1;</code>
       */
      BUILDING(1),
      /**
       * <pre>
       * Unconfirmed and sitting in the networks memory pools, waiting to be included in the chain.
       * </pre>
       *
       * <code>PENDING = 2;</code>
       */
      PENDING(2),
      /**
       * <pre>
       * Deprecated: equivalent to PENDING.
       * </pre>
       *
       * <code>NOT_IN_BEST_CHAIN = 3;</code>
       */
      NOT_IN_BEST_CHAIN(3),
      /**
       * <pre>
       * Either if overriding_transaction is present or transaction is dead coinbase.
       * </pre>
       *
       * <code>DEAD = 4;</code>
       */
      DEAD(4),
      /**
       * <pre>
       * There is another transaction spending one of this transaction inputs.
       * </pre>
       *
       * <code>IN_CONFLICT = 5;</code>
       */
      IN_CONFLICT(5),
      ;

      /**
       * <pre>
       * See TransactionConfidence.java for a more thorough explanation of these types.
       * </pre>
       *
       * <code>UNKNOWN = 0;</code>
       */
      public static final int UNKNOWN_VALUE = 0;
      /**
       * <pre>
       * In best chain.  If and only if appeared_at_height is present.
       * </pre>
       *
       * <code>BUILDING = 1;</code>
       */
      public static final int BUILDING_VALUE = 1;
      /**
       * <pre>
       * Unconfirmed and sitting in the networks memory pools, waiting to be included in the chain.
       * </pre>
       *
       * <code>PENDING = 2;</code>
       */
      public static final int PENDING_VALUE = 2;
      /**
       * <pre>
       * Deprecated: equivalent to PENDING.
       * </pre>
       *
       * <code>NOT_IN_BEST_CHAIN = 3;</code>
       */
      public static final int NOT_IN_BEST_CHAIN_VALUE = 3;
      /**
       * <pre>
       * Either if overriding_transaction is present or transaction is dead coinbase.
       * </pre>
       *
       * <code>DEAD = 4;</code>
       */
      public static final int DEAD_VALUE = 4;
      /**
       * <pre>
       * There is another transaction spending one of this transaction inputs.
       * </pre>
       *
       * <code>IN_CONFLICT = 5;</code>
       */
      public static final int IN_CONFLICT_VALUE = 5;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      public static Type forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN;
          case 1: return BUILDING;
          case 2: return PENDING;
          case 3: return NOT_IN_BEST_CHAIN;
          case 4: return DEAD;
          case 5: return IN_CONFLICT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              @java.lang.Override
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return TypeVerifier.INSTANCE;
      }

      private static final class TypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new TypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Type.forNumber(number) != null;
              }
            };

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:wallet.TransactionConfidence.Type)
    }

    /**
     * <pre>
     * Where did we get this transaction from? Knowing the source may help us to risk analyze pending transactions.
     * </pre>
     *
     * Protobuf enum {@code wallet.TransactionConfidence.Source}
     */
    public enum Source
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * We don't know where it came from, or this is a wallet from the future.
       * </pre>
       *
       * <code>SOURCE_UNKNOWN = 0;</code>
       */
      SOURCE_UNKNOWN(0),
      /**
       * <pre>
       * We received it from a network broadcast. This is the normal way to get payments.
       * </pre>
       *
       * <code>SOURCE_NETWORK = 1;</code>
       */
      SOURCE_NETWORK(1),
      /**
       * <pre>
       * We made it ourselves, so we know it should be valid.
       * </pre>
       *
       * <code>SOURCE_SELF = 2;</code>
       */
      SOURCE_SELF(2),
      ;

      /**
       * <pre>
       * We don't know where it came from, or this is a wallet from the future.
       * </pre>
       *
       * <code>SOURCE_UNKNOWN = 0;</code>
       */
      public static final int SOURCE_UNKNOWN_VALUE = 0;
      /**
       * <pre>
       * We received it from a network broadcast. This is the normal way to get payments.
       * </pre>
       *
       * <code>SOURCE_NETWORK = 1;</code>
       */
      public static final int SOURCE_NETWORK_VALUE = 1;
      /**
       * <pre>
       * We made it ourselves, so we know it should be valid.
       * </pre>
       *
       * <code>SOURCE_SELF = 2;</code>
       */
      public static final int SOURCE_SELF_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Source valueOf(int value) {
        return forNumber(value);
      }

      public static Source forNumber(int value) {
        switch (value) {
          case 0: return SOURCE_UNKNOWN;
          case 1: return SOURCE_NETWORK;
          case 2: return SOURCE_SELF;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Source>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Source> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Source>() {
              @java.lang.Override
              public Source findValueByNumber(int number) {
                return Source.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return SourceVerifier.INSTANCE;
      }

      private static final class SourceVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SourceVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Source.forNumber(number) != null;
              }
            };

      private final int value;

      private Source(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:wallet.TransactionConfidence.Source)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <pre>
     * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.TransactionConfidence.Type getType() {
      org.bitcoinj.wallet.Protos.TransactionConfidence.Type result = org.bitcoinj.wallet.Protos.TransactionConfidence.Type.forNumber(type_);
      return result == null ? org.bitcoinj.wallet.Protos.TransactionConfidence.Type.UNKNOWN : result;
    }
    /**
     * <pre>
     * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
     * @param value The type to set.
     */
    private void setType(org.bitcoinj.wallet.Protos.TransactionConfidence.Type value) {
      type_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      type_ = 0;
    }

    public static final int APPEARED_AT_HEIGHT_FIELD_NUMBER = 2;
    private int appearedAtHeight_;
    /**
     * <pre>
     * If type == BUILDING then this is the chain height at which the transaction was included.
     * </pre>
     *
     * <code>optional int32 appeared_at_height = 2;</code>
     * @return Whether the appearedAtHeight field is set.
     */
    @java.lang.Override
    public boolean hasAppearedAtHeight() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If type == BUILDING then this is the chain height at which the transaction was included.
     * </pre>
     *
     * <code>optional int32 appeared_at_height = 2;</code>
     * @return The appearedAtHeight.
     */
    @java.lang.Override
    public int getAppearedAtHeight() {
      return appearedAtHeight_;
    }
    /**
     * <pre>
     * If type == BUILDING then this is the chain height at which the transaction was included.
     * </pre>
     *
     * <code>optional int32 appeared_at_height = 2;</code>
     * @param value The appearedAtHeight to set.
     */
    private void setAppearedAtHeight(int value) {
      bitField0_ |= 0x00000002;
      appearedAtHeight_ = value;
    }
    /**
     * <pre>
     * If type == BUILDING then this is the chain height at which the transaction was included.
     * </pre>
     *
     * <code>optional int32 appeared_at_height = 2;</code>
     */
    private void clearAppearedAtHeight() {
      bitField0_ = (bitField0_ & ~0x00000002);
      appearedAtHeight_ = 0;
    }

    public static final int OVERRIDING_TRANSACTION_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString overridingTransaction_;
    /**
     * <pre>
     * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
     * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
     * bother to track them all, just the first. This only makes sense if type = DEAD.
     * </pre>
     *
     * <code>optional bytes overriding_transaction = 3;</code>
     * @return Whether the overridingTransaction field is set.
     */
    @java.lang.Override
    public boolean hasOverridingTransaction() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
     * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
     * bother to track them all, just the first. This only makes sense if type = DEAD.
     * </pre>
     *
     * <code>optional bytes overriding_transaction = 3;</code>
     * @return The overridingTransaction.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getOverridingTransaction() {
      return overridingTransaction_;
    }
    /**
     * <pre>
     * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
     * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
     * bother to track them all, just the first. This only makes sense if type = DEAD.
     * </pre>
     *
     * <code>optional bytes overriding_transaction = 3;</code>
     * @param value The overridingTransaction to set.
     */
    private void setOverridingTransaction(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      overridingTransaction_ = value;
    }
    /**
     * <pre>
     * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
     * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
     * bother to track them all, just the first. This only makes sense if type = DEAD.
     * </pre>
     *
     * <code>optional bytes overriding_transaction = 3;</code>
     */
    private void clearOverridingTransaction() {
      bitField0_ = (bitField0_ & ~0x00000004);
      overridingTransaction_ = getDefaultInstance().getOverridingTransaction();
    }

    public static final int DEPTH_FIELD_NUMBER = 4;
    private int depth_;
    /**
     * <pre>
     * If type == BUILDING then this is the depth of the transaction in the blockchain.
     * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
     * </pre>
     *
     * <code>optional int32 depth = 4;</code>
     * @return Whether the depth field is set.
     */
    @java.lang.Override
    public boolean hasDepth() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If type == BUILDING then this is the depth of the transaction in the blockchain.
     * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
     * </pre>
     *
     * <code>optional int32 depth = 4;</code>
     * @return The depth.
     */
    @java.lang.Override
    public int getDepth() {
      return depth_;
    }
    /**
     * <pre>
     * If type == BUILDING then this is the depth of the transaction in the blockchain.
     * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
     * </pre>
     *
     * <code>optional int32 depth = 4;</code>
     * @param value The depth to set.
     */
    private void setDepth(int value) {
      bitField0_ |= 0x00000008;
      depth_ = value;
    }
    /**
     * <pre>
     * If type == BUILDING then this is the depth of the transaction in the blockchain.
     * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
     * </pre>
     *
     * <code>optional int32 depth = 4;</code>
     */
    private void clearDepth() {
      bitField0_ = (bitField0_ & ~0x00000008);
      depth_ = 0;
    }

    public static final int BROADCAST_BY_FIELD_NUMBER = 6;
    private com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.PeerAddress> broadcastBy_;
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    @java.lang.Override
    public java.util.List<org.bitcoinj.wallet.Protos.PeerAddress> getBroadcastByList() {
      return broadcastBy_;
    }
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    public java.util.List<? extends org.bitcoinj.wallet.Protos.PeerAddressOrBuilder> 
        getBroadcastByOrBuilderList() {
      return broadcastBy_;
    }
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    @java.lang.Override
    public int getBroadcastByCount() {
      return broadcastBy_.size();
    }
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.PeerAddress getBroadcastBy(int index) {
      return broadcastBy_.get(index);
    }
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    public org.bitcoinj.wallet.Protos.PeerAddressOrBuilder getBroadcastByOrBuilder(
        int index) {
      return broadcastBy_.get(index);
    }
    private void ensureBroadcastByIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.PeerAddress> tmp = broadcastBy_;
      if (!tmp.isModifiable()) {
        broadcastBy_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    private void setBroadcastBy(
        int index, org.bitcoinj.wallet.Protos.PeerAddress value) {
      value.getClass();
  ensureBroadcastByIsMutable();
      broadcastBy_.set(index, value);
    }
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    private void addBroadcastBy(org.bitcoinj.wallet.Protos.PeerAddress value) {
      value.getClass();
  ensureBroadcastByIsMutable();
      broadcastBy_.add(value);
    }
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    private void addBroadcastBy(
        int index, org.bitcoinj.wallet.Protos.PeerAddress value) {
      value.getClass();
  ensureBroadcastByIsMutable();
      broadcastBy_.add(index, value);
    }
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    private void addAllBroadcastBy(
        java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.PeerAddress> values) {
      ensureBroadcastByIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, broadcastBy_);
    }
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    private void clearBroadcastBy() {
      broadcastBy_ = emptyProtobufList();
    }
    /**
     * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
     */
    private void removeBroadcastBy(int index) {
      ensureBroadcastByIsMutable();
      broadcastBy_.remove(index);
    }

    public static final int LAST_BROADCASTED_AT_FIELD_NUMBER = 8;
    private long lastBroadcastedAt_;
    /**
     * <pre>
     * Millis since epoch the transaction was last announced to us.
     * </pre>
     *
     * <code>optional int64 last_broadcasted_at = 8;</code>
     * @return Whether the lastBroadcastedAt field is set.
     */
    @java.lang.Override
    public boolean hasLastBroadcastedAt() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Millis since epoch the transaction was last announced to us.
     * </pre>
     *
     * <code>optional int64 last_broadcasted_at = 8;</code>
     * @return The lastBroadcastedAt.
     */
    @java.lang.Override
    public long getLastBroadcastedAt() {
      return lastBroadcastedAt_;
    }
    /**
     * <pre>
     * Millis since epoch the transaction was last announced to us.
     * </pre>
     *
     * <code>optional int64 last_broadcasted_at = 8;</code>
     * @param value The lastBroadcastedAt to set.
     */
    private void setLastBroadcastedAt(long value) {
      bitField0_ |= 0x00000010;
      lastBroadcastedAt_ = value;
    }
    /**
     * <pre>
     * Millis since epoch the transaction was last announced to us.
     * </pre>
     *
     * <code>optional int64 last_broadcasted_at = 8;</code>
     */
    private void clearLastBroadcastedAt() {
      bitField0_ = (bitField0_ & ~0x00000010);
      lastBroadcastedAt_ = 0L;
    }

    public static final int SOURCE_FIELD_NUMBER = 7;
    private int source_;
    /**
     * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
     * @return Whether the source field is set.
     */
    @java.lang.Override
    public boolean hasSource() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
     * @return The source.
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.TransactionConfidence.Source getSource() {
      org.bitcoinj.wallet.Protos.TransactionConfidence.Source result = org.bitcoinj.wallet.Protos.TransactionConfidence.Source.forNumber(source_);
      return result == null ? org.bitcoinj.wallet.Protos.TransactionConfidence.Source.SOURCE_UNKNOWN : result;
    }
    /**
     * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
     * @param value The source to set.
     */
    private void setSource(org.bitcoinj.wallet.Protos.TransactionConfidence.Source value) {
      source_ = value.getNumber();
      bitField0_ |= 0x00000020;
    }
    /**
     * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
     */
    private void clearSource() {
      bitField0_ = (bitField0_ & ~0x00000020);
      source_ = 0;
    }

    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.TransactionConfidence parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.TransactionConfidence prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     **
     * A description of the confidence we have that a transaction cannot be reversed in the future.
     * Parsing should be lenient, since this could change for different applications yet we should
     * maintain backward compatibility.
     * </pre>
     *
     * Protobuf type {@code wallet.TransactionConfidence}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.TransactionConfidence, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.TransactionConfidence)
        org.bitcoinj.wallet.Protos.TransactionConfidenceOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.TransactionConfidence.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <pre>
       * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.TransactionConfidence.Type getType() {
        return instance.getType();
      }
      /**
       * <pre>
       * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.bitcoinj.wallet.Protos.TransactionConfidence.Type value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <pre>
       * This is optional in case we add confidence types to prevent parse errors - backwards compatible.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence.Type type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <pre>
       * If type == BUILDING then this is the chain height at which the transaction was included.
       * </pre>
       *
       * <code>optional int32 appeared_at_height = 2;</code>
       * @return Whether the appearedAtHeight field is set.
       */
      @java.lang.Override
      public boolean hasAppearedAtHeight() {
        return instance.hasAppearedAtHeight();
      }
      /**
       * <pre>
       * If type == BUILDING then this is the chain height at which the transaction was included.
       * </pre>
       *
       * <code>optional int32 appeared_at_height = 2;</code>
       * @return The appearedAtHeight.
       */
      @java.lang.Override
      public int getAppearedAtHeight() {
        return instance.getAppearedAtHeight();
      }
      /**
       * <pre>
       * If type == BUILDING then this is the chain height at which the transaction was included.
       * </pre>
       *
       * <code>optional int32 appeared_at_height = 2;</code>
       * @param value The appearedAtHeight to set.
       * @return This builder for chaining.
       */
      public Builder setAppearedAtHeight(int value) {
        copyOnWrite();
        instance.setAppearedAtHeight(value);
        return this;
      }
      /**
       * <pre>
       * If type == BUILDING then this is the chain height at which the transaction was included.
       * </pre>
       *
       * <code>optional int32 appeared_at_height = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAppearedAtHeight() {
        copyOnWrite();
        instance.clearAppearedAtHeight();
        return this;
      }

      /**
       * <pre>
       * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
       * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
       * bother to track them all, just the first. This only makes sense if type = DEAD.
       * </pre>
       *
       * <code>optional bytes overriding_transaction = 3;</code>
       * @return Whether the overridingTransaction field is set.
       */
      @java.lang.Override
      public boolean hasOverridingTransaction() {
        return instance.hasOverridingTransaction();
      }
      /**
       * <pre>
       * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
       * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
       * bother to track them all, just the first. This only makes sense if type = DEAD.
       * </pre>
       *
       * <code>optional bytes overriding_transaction = 3;</code>
       * @return The overridingTransaction.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getOverridingTransaction() {
        return instance.getOverridingTransaction();
      }
      /**
       * <pre>
       * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
       * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
       * bother to track them all, just the first. This only makes sense if type = DEAD.
       * </pre>
       *
       * <code>optional bytes overriding_transaction = 3;</code>
       * @param value The overridingTransaction to set.
       * @return This builder for chaining.
       */
      public Builder setOverridingTransaction(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setOverridingTransaction(value);
        return this;
      }
      /**
       * <pre>
       * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
       * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
       * bother to track them all, just the first. This only makes sense if type = DEAD.
       * </pre>
       *
       * <code>optional bytes overriding_transaction = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearOverridingTransaction() {
        copyOnWrite();
        instance.clearOverridingTransaction();
        return this;
      }

      /**
       * <pre>
       * If type == BUILDING then this is the depth of the transaction in the blockchain.
       * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
       * </pre>
       *
       * <code>optional int32 depth = 4;</code>
       * @return Whether the depth field is set.
       */
      @java.lang.Override
      public boolean hasDepth() {
        return instance.hasDepth();
      }
      /**
       * <pre>
       * If type == BUILDING then this is the depth of the transaction in the blockchain.
       * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
       * </pre>
       *
       * <code>optional int32 depth = 4;</code>
       * @return The depth.
       */
      @java.lang.Override
      public int getDepth() {
        return instance.getDepth();
      }
      /**
       * <pre>
       * If type == BUILDING then this is the depth of the transaction in the blockchain.
       * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
       * </pre>
       *
       * <code>optional int32 depth = 4;</code>
       * @param value The depth to set.
       * @return This builder for chaining.
       */
      public Builder setDepth(int value) {
        copyOnWrite();
        instance.setDepth(value);
        return this;
      }
      /**
       * <pre>
       * If type == BUILDING then this is the depth of the transaction in the blockchain.
       * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
       * </pre>
       *
       * <code>optional int32 depth = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDepth() {
        copyOnWrite();
        instance.clearDepth();
        return this;
      }

      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      @java.lang.Override
      public java.util.List<org.bitcoinj.wallet.Protos.PeerAddress> getBroadcastByList() {
        return java.util.Collections.unmodifiableList(
            instance.getBroadcastByList());
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      @java.lang.Override
      public int getBroadcastByCount() {
        return instance.getBroadcastByCount();
      }/**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.PeerAddress getBroadcastBy(int index) {
        return instance.getBroadcastBy(index);
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      public Builder setBroadcastBy(
          int index, org.bitcoinj.wallet.Protos.PeerAddress value) {
        copyOnWrite();
        instance.setBroadcastBy(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      public Builder setBroadcastBy(
          int index, org.bitcoinj.wallet.Protos.PeerAddress.Builder builderForValue) {
        copyOnWrite();
        instance.setBroadcastBy(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      public Builder addBroadcastBy(org.bitcoinj.wallet.Protos.PeerAddress value) {
        copyOnWrite();
        instance.addBroadcastBy(value);
        return this;
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      public Builder addBroadcastBy(
          int index, org.bitcoinj.wallet.Protos.PeerAddress value) {
        copyOnWrite();
        instance.addBroadcastBy(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      public Builder addBroadcastBy(
          org.bitcoinj.wallet.Protos.PeerAddress.Builder builderForValue) {
        copyOnWrite();
        instance.addBroadcastBy(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      public Builder addBroadcastBy(
          int index, org.bitcoinj.wallet.Protos.PeerAddress.Builder builderForValue) {
        copyOnWrite();
        instance.addBroadcastBy(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      public Builder addAllBroadcastBy(
          java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.PeerAddress> values) {
        copyOnWrite();
        instance.addAllBroadcastBy(values);
        return this;
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      public Builder clearBroadcastBy() {
        copyOnWrite();
        instance.clearBroadcastBy();
        return this;
      }
      /**
       * <code>repeated .wallet.PeerAddress broadcast_by = 6;</code>
       */
      public Builder removeBroadcastBy(int index) {
        copyOnWrite();
        instance.removeBroadcastBy(index);
        return this;
      }

      /**
       * <pre>
       * Millis since epoch the transaction was last announced to us.
       * </pre>
       *
       * <code>optional int64 last_broadcasted_at = 8;</code>
       * @return Whether the lastBroadcastedAt field is set.
       */
      @java.lang.Override
      public boolean hasLastBroadcastedAt() {
        return instance.hasLastBroadcastedAt();
      }
      /**
       * <pre>
       * Millis since epoch the transaction was last announced to us.
       * </pre>
       *
       * <code>optional int64 last_broadcasted_at = 8;</code>
       * @return The lastBroadcastedAt.
       */
      @java.lang.Override
      public long getLastBroadcastedAt() {
        return instance.getLastBroadcastedAt();
      }
      /**
       * <pre>
       * Millis since epoch the transaction was last announced to us.
       * </pre>
       *
       * <code>optional int64 last_broadcasted_at = 8;</code>
       * @param value The lastBroadcastedAt to set.
       * @return This builder for chaining.
       */
      public Builder setLastBroadcastedAt(long value) {
        copyOnWrite();
        instance.setLastBroadcastedAt(value);
        return this;
      }
      /**
       * <pre>
       * Millis since epoch the transaction was last announced to us.
       * </pre>
       *
       * <code>optional int64 last_broadcasted_at = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastBroadcastedAt() {
        copyOnWrite();
        instance.clearLastBroadcastedAt();
        return this;
      }

      /**
       * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
       * @return Whether the source field is set.
       */
      @java.lang.Override
      public boolean hasSource() {
        return instance.hasSource();
      }
      /**
       * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
       * @return The source.
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.TransactionConfidence.Source getSource() {
        return instance.getSource();
      }
      /**
       * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
       * @param value The enum numeric value on the wire for source to set.
       * @return This builder for chaining.
       */
      public Builder setSource(org.bitcoinj.wallet.Protos.TransactionConfidence.Source value) {
        copyOnWrite();
        instance.setSource(value);
        return this;
      }
      /**
       * <code>optional .wallet.TransactionConfidence.Source source = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearSource() {
        copyOnWrite();
        instance.clearSource();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.TransactionConfidence)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.TransactionConfidence();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "type_",
              org.bitcoinj.wallet.Protos.TransactionConfidence.Type.internalGetVerifier(),
              "appearedAtHeight_",
              "overridingTransaction_",
              "depth_",
              "broadcastBy_",
              org.bitcoinj.wallet.Protos.PeerAddress.class,
              "source_",
              org.bitcoinj.wallet.Protos.TransactionConfidence.Source.internalGetVerifier(),
              "lastBroadcastedAt_",
            };
            java.lang.String info =
                "\u0001\u0007\u0000\u0001\u0001\b\u0007\u0000\u0001\u0001\u0001\u100c\u0000\u0002" +
                "\u1004\u0001\u0003\u100a\u0002\u0004\u1004\u0003\u0006\u041b\u0007\u100c\u0005\b" +
                "\u1002\u0004";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.TransactionConfidence> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.TransactionConfidence.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.TransactionConfidence>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.TransactionConfidence)
    private static final org.bitcoinj.wallet.Protos.TransactionConfidence DEFAULT_INSTANCE;
    static {
      TransactionConfidence defaultInstance = new TransactionConfidence();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TransactionConfidence.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.TransactionConfidence getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TransactionConfidence> PARSER;

    public static com.google.protobuf.Parser<TransactionConfidence> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TransactionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.Transaction)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * See Wallet.java for detailed description of pool semantics
     * </pre>
     *
     * <code>required int32 version = 1;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <pre>
     * See Wallet.java for detailed description of pool semantics
     * </pre>
     *
     * <code>required int32 version = 1;</code>
     * @return The version.
     */
    int getVersion();

    /**
     * <code>required bytes hash = 2;</code>
     * @return Whether the hash field is set.
     */
    boolean hasHash();
    /**
     * <code>required bytes hash = 2;</code>
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();

    /**
     * <pre>
     * If pool is not present, that means either:
     *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
     *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
     *  - Or the Pool enum got a new value which your software is too old to parse.
     * </pre>
     *
     * <code>optional .wallet.Transaction.Pool pool = 3;</code>
     * @return Whether the pool field is set.
     */
    boolean hasPool();
    /**
     * <pre>
     * If pool is not present, that means either:
     *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
     *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
     *  - Or the Pool enum got a new value which your software is too old to parse.
     * </pre>
     *
     * <code>optional .wallet.Transaction.Pool pool = 3;</code>
     * @return The pool.
     */
    org.bitcoinj.wallet.Protos.Transaction.Pool getPool();

    /**
     * <pre>
     * The nLockTime field is useful for contracts.
     * </pre>
     *
     * <code>optional uint32 lock_time = 4;</code>
     * @return Whether the lockTime field is set.
     */
    boolean hasLockTime();
    /**
     * <pre>
     * The nLockTime field is useful for contracts.
     * </pre>
     *
     * <code>optional uint32 lock_time = 4;</code>
     * @return The lockTime.
     */
    int getLockTime();

    /**
     * <pre>
     * millis since epoch the transaction was last updated
     * </pre>
     *
     * <code>optional int64 updated_at = 5;</code>
     * @return Whether the updatedAt field is set.
     */
    boolean hasUpdatedAt();
    /**
     * <pre>
     * millis since epoch the transaction was last updated
     * </pre>
     *
     * <code>optional int64 updated_at = 5;</code>
     * @return The updatedAt.
     */
    long getUpdatedAt();

    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    java.util.List<org.bitcoinj.wallet.Protos.TransactionInput> 
        getTransactionInputList();
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    org.bitcoinj.wallet.Protos.TransactionInput getTransactionInput(int index);
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    int getTransactionInputCount();

    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    java.util.List<org.bitcoinj.wallet.Protos.TransactionOutput> 
        getTransactionOutputList();
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    org.bitcoinj.wallet.Protos.TransactionOutput getTransactionOutput(int index);
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    int getTransactionOutputCount();

    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     * @return A list containing the blockHash.
     */
    java.util.List<com.google.protobuf.ByteString> getBlockHashList();
    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     * @return The count of blockHash.
     */
    int getBlockHashCount();
    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     * @param index The index of the element to return.
     * @return The blockHash at the given index.
     */
    com.google.protobuf.ByteString getBlockHash(int index);

    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     * @return A list containing the blockRelativityOffsets.
     */
    java.util.List<java.lang.Integer> getBlockRelativityOffsetsList();
    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     * @return The count of blockRelativityOffsets.
     */
    int getBlockRelativityOffsetsCount();
    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     * @param index The index of the element to return.
     * @return The blockRelativityOffsets at the given index.
     */
    int getBlockRelativityOffsets(int index);

    /**
     * <pre>
     * Data describing where the transaction is in the chain.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
     * @return Whether the confidence field is set.
     */
    boolean hasConfidence();
    /**
     * <pre>
     * Data describing where the transaction is in the chain.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
     * @return The confidence.
     */
    org.bitcoinj.wallet.Protos.TransactionConfidence getConfidence();

    /**
     * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
     * @return Whether the purpose field is set.
     */
    boolean hasPurpose();
    /**
     * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
     * @return The purpose.
     */
    org.bitcoinj.wallet.Protos.Transaction.Purpose getPurpose();

    /**
     * <pre>
     * Exchange rate that was valid when the transaction was sent.
     * </pre>
     *
     * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
     * @return Whether the exchangeRate field is set.
     */
    boolean hasExchangeRate();
    /**
     * <pre>
     * Exchange rate that was valid when the transaction was sent.
     * </pre>
     *
     * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
     * @return The exchangeRate.
     */
    org.bitcoinj.wallet.Protos.ExchangeRate getExchangeRate();

    /**
     * <pre>
     * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
     * transaction.
     * </pre>
     *
     * <code>optional string memo = 13;</code>
     * @return Whether the memo field is set.
     */
    boolean hasMemo();
    /**
     * <pre>
     * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
     * transaction.
     * </pre>
     *
     * <code>optional string memo = 13;</code>
     * @return The memo.
     */
    java.lang.String getMemo();
    /**
     * <pre>
     * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
     * transaction.
     * </pre>
     *
     * <code>optional string memo = 13;</code>
     * @return The bytes for memo.
     */
    com.google.protobuf.ByteString
        getMemoBytes();
  }
  /**
   * Protobuf type {@code wallet.Transaction}
   */
  public  static final class Transaction extends
      com.google.protobuf.GeneratedMessageLite<
          Transaction, Transaction.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.Transaction)
      TransactionOrBuilder {
    private Transaction() {
      hash_ = com.google.protobuf.ByteString.EMPTY;
      pool_ = 4;
      transactionInput_ = emptyProtobufList();
      transactionOutput_ = emptyProtobufList();
      blockHash_ = emptyProtobufList();
      blockRelativityOffsets_ = emptyIntList();
      memo_ = "";
    }
    /**
     * <pre>
     **
     * This is a bitfield oriented enum, with the following bits:
     * 
     * bit 0 - spent
     * bit 1 - appears in alt chain
     * bit 2 - appears in best chain
     * bit 3 - double-spent
     * bit 4 - pending (we would like the tx to go into the best chain)
     * 
     * Not all combinations are interesting, just the ones actually used in the enum.
     * </pre>
     *
     * Protobuf enum {@code wallet.Transaction.Pool}
     */
    public enum Pool
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * In best chain, not all outputs spent
       * </pre>
       *
       * <code>UNSPENT = 4;</code>
       */
      UNSPENT(4),
      /**
       * <pre>
       * In best chain, all outputs spent
       * </pre>
       *
       * <code>SPENT = 5;</code>
       */
      SPENT(5),
      /**
       * <pre>
       * In non-best chain, not our transaction
       * </pre>
       *
       * <code>INACTIVE = 2;</code>
       */
      INACTIVE(2),
      /**
       * <pre>
       * Double-spent by a transaction in the best chain
       * </pre>
       *
       * <code>DEAD = 10;</code>
       */
      DEAD(10),
      /**
       * <pre>
       * Our transaction, not in any chain
       * </pre>
       *
       * <code>PENDING = 16;</code>
       */
      PENDING(16),
      /**
       * <pre>
       * In non-best chain, our transaction
       * </pre>
       *
       * <code>PENDING_INACTIVE = 18;</code>
       */
      PENDING_INACTIVE(18),
      ;

      /**
       * <pre>
       * In best chain, not all outputs spent
       * </pre>
       *
       * <code>UNSPENT = 4;</code>
       */
      public static final int UNSPENT_VALUE = 4;
      /**
       * <pre>
       * In best chain, all outputs spent
       * </pre>
       *
       * <code>SPENT = 5;</code>
       */
      public static final int SPENT_VALUE = 5;
      /**
       * <pre>
       * In non-best chain, not our transaction
       * </pre>
       *
       * <code>INACTIVE = 2;</code>
       */
      public static final int INACTIVE_VALUE = 2;
      /**
       * <pre>
       * Double-spent by a transaction in the best chain
       * </pre>
       *
       * <code>DEAD = 10;</code>
       */
      public static final int DEAD_VALUE = 10;
      /**
       * <pre>
       * Our transaction, not in any chain
       * </pre>
       *
       * <code>PENDING = 16;</code>
       */
      public static final int PENDING_VALUE = 16;
      /**
       * <pre>
       * In non-best chain, our transaction
       * </pre>
       *
       * <code>PENDING_INACTIVE = 18;</code>
       */
      public static final int PENDING_INACTIVE_VALUE = 18;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Pool valueOf(int value) {
        return forNumber(value);
      }

      public static Pool forNumber(int value) {
        switch (value) {
          case 4: return UNSPENT;
          case 5: return SPENT;
          case 2: return INACTIVE;
          case 10: return DEAD;
          case 16: return PENDING;
          case 18: return PENDING_INACTIVE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Pool>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Pool> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Pool>() {
              @java.lang.Override
              public Pool findValueByNumber(int number) {
                return Pool.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return PoolVerifier.INSTANCE;
      }

      private static final class PoolVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PoolVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Pool.forNumber(number) != null;
              }
            };

      private final int value;

      private Pool(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:wallet.Transaction.Pool)
    }

    /**
     * <pre>
     * For what purpose the transaction was created.
     * </pre>
     *
     * Protobuf enum {@code wallet.Transaction.Purpose}
     */
    public enum Purpose
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Old wallets or the purpose genuinely is a mystery (e.g. imported from some external source).
       * </pre>
       *
       * <code>UNKNOWN = 0;</code>
       */
      UNKNOWN(0),
      /**
       * <pre>
       * Created in response to a user request for payment. This is the normal case.
       * </pre>
       *
       * <code>USER_PAYMENT = 1;</code>
       */
      USER_PAYMENT(1),
      /**
       * <pre>
       * Created automatically to move money from rotated keys.
       * </pre>
       *
       * <code>KEY_ROTATION = 2;</code>
       */
      KEY_ROTATION(2),
      /**
       * <pre>
       * Stuff used by Lighthouse.
       * </pre>
       *
       * <code>ASSURANCE_CONTRACT_CLAIM = 3;</code>
       */
      ASSURANCE_CONTRACT_CLAIM(3),
      /**
       * <code>ASSURANCE_CONTRACT_PLEDGE = 4;</code>
       */
      ASSURANCE_CONTRACT_PLEDGE(4),
      /**
       * <code>ASSURANCE_CONTRACT_STUB = 5;</code>
       */
      ASSURANCE_CONTRACT_STUB(5),
      /**
       * <pre>
       * Raise fee, e.g. child-pays-for-parent.
       * </pre>
       *
       * <code>RAISE_FEE = 6;</code>
       */
      RAISE_FEE(6),
      ;

      /**
       * <pre>
       * Old wallets or the purpose genuinely is a mystery (e.g. imported from some external source).
       * </pre>
       *
       * <code>UNKNOWN = 0;</code>
       */
      public static final int UNKNOWN_VALUE = 0;
      /**
       * <pre>
       * Created in response to a user request for payment. This is the normal case.
       * </pre>
       *
       * <code>USER_PAYMENT = 1;</code>
       */
      public static final int USER_PAYMENT_VALUE = 1;
      /**
       * <pre>
       * Created automatically to move money from rotated keys.
       * </pre>
       *
       * <code>KEY_ROTATION = 2;</code>
       */
      public static final int KEY_ROTATION_VALUE = 2;
      /**
       * <pre>
       * Stuff used by Lighthouse.
       * </pre>
       *
       * <code>ASSURANCE_CONTRACT_CLAIM = 3;</code>
       */
      public static final int ASSURANCE_CONTRACT_CLAIM_VALUE = 3;
      /**
       * <code>ASSURANCE_CONTRACT_PLEDGE = 4;</code>
       */
      public static final int ASSURANCE_CONTRACT_PLEDGE_VALUE = 4;
      /**
       * <code>ASSURANCE_CONTRACT_STUB = 5;</code>
       */
      public static final int ASSURANCE_CONTRACT_STUB_VALUE = 5;
      /**
       * <pre>
       * Raise fee, e.g. child-pays-for-parent.
       * </pre>
       *
       * <code>RAISE_FEE = 6;</code>
       */
      public static final int RAISE_FEE_VALUE = 6;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Purpose valueOf(int value) {
        return forNumber(value);
      }

      public static Purpose forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN;
          case 1: return USER_PAYMENT;
          case 2: return KEY_ROTATION;
          case 3: return ASSURANCE_CONTRACT_CLAIM;
          case 4: return ASSURANCE_CONTRACT_PLEDGE;
          case 5: return ASSURANCE_CONTRACT_STUB;
          case 6: return RAISE_FEE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Purpose>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Purpose> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Purpose>() {
              @java.lang.Override
              public Purpose findValueByNumber(int number) {
                return Purpose.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return PurposeVerifier.INSTANCE;
      }

      private static final class PurposeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PurposeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Purpose.forNumber(number) != null;
              }
            };

      private final int value;

      private Purpose(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:wallet.Transaction.Purpose)
    }

    private int bitField0_;
    public static final int VERSION_FIELD_NUMBER = 1;
    private int version_;
    /**
     * <pre>
     * See Wallet.java for detailed description of pool semantics
     * </pre>
     *
     * <code>required int32 version = 1;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * See Wallet.java for detailed description of pool semantics
     * </pre>
     *
     * <code>required int32 version = 1;</code>
     * @return The version.
     */
    @java.lang.Override
    public int getVersion() {
      return version_;
    }
    /**
     * <pre>
     * See Wallet.java for detailed description of pool semantics
     * </pre>
     *
     * <code>required int32 version = 1;</code>
     * @param value The version to set.
     */
    private void setVersion(int value) {
      bitField0_ |= 0x00000001;
      version_ = value;
    }
    /**
     * <pre>
     * See Wallet.java for detailed description of pool semantics
     * </pre>
     *
     * <code>required int32 version = 1;</code>
     */
    private void clearVersion() {
      bitField0_ = (bitField0_ & ~0x00000001);
      version_ = 0;
    }

    public static final int HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString hash_;
    /**
     * <code>required bytes hash = 2;</code>
     * @return Whether the hash field is set.
     */
    @java.lang.Override
    public boolean hasHash() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>required bytes hash = 2;</code>
     * @return The hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }
    /**
     * <code>required bytes hash = 2;</code>
     * @param value The hash to set.
     */
    private void setHash(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      hash_ = value;
    }
    /**
     * <code>required bytes hash = 2;</code>
     */
    private void clearHash() {
      bitField0_ = (bitField0_ & ~0x00000002);
      hash_ = getDefaultInstance().getHash();
    }

    public static final int POOL_FIELD_NUMBER = 3;
    private int pool_;
    /**
     * <pre>
     * If pool is not present, that means either:
     *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
     *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
     *  - Or the Pool enum got a new value which your software is too old to parse.
     * </pre>
     *
     * <code>optional .wallet.Transaction.Pool pool = 3;</code>
     * @return Whether the pool field is set.
     */
    @java.lang.Override
    public boolean hasPool() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If pool is not present, that means either:
     *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
     *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
     *  - Or the Pool enum got a new value which your software is too old to parse.
     * </pre>
     *
     * <code>optional .wallet.Transaction.Pool pool = 3;</code>
     * @return The pool.
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Transaction.Pool getPool() {
      org.bitcoinj.wallet.Protos.Transaction.Pool result = org.bitcoinj.wallet.Protos.Transaction.Pool.forNumber(pool_);
      return result == null ? org.bitcoinj.wallet.Protos.Transaction.Pool.UNSPENT : result;
    }
    /**
     * <pre>
     * If pool is not present, that means either:
     *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
     *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
     *  - Or the Pool enum got a new value which your software is too old to parse.
     * </pre>
     *
     * <code>optional .wallet.Transaction.Pool pool = 3;</code>
     * @param value The pool to set.
     */
    private void setPool(org.bitcoinj.wallet.Protos.Transaction.Pool value) {
      pool_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * If pool is not present, that means either:
     *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
     *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
     *  - Or the Pool enum got a new value which your software is too old to parse.
     * </pre>
     *
     * <code>optional .wallet.Transaction.Pool pool = 3;</code>
     */
    private void clearPool() {
      bitField0_ = (bitField0_ & ~0x00000004);
      pool_ = 4;
    }

    public static final int LOCK_TIME_FIELD_NUMBER = 4;
    private int lockTime_;
    /**
     * <pre>
     * The nLockTime field is useful for contracts.
     * </pre>
     *
     * <code>optional uint32 lock_time = 4;</code>
     * @return Whether the lockTime field is set.
     */
    @java.lang.Override
    public boolean hasLockTime() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The nLockTime field is useful for contracts.
     * </pre>
     *
     * <code>optional uint32 lock_time = 4;</code>
     * @return The lockTime.
     */
    @java.lang.Override
    public int getLockTime() {
      return lockTime_;
    }
    /**
     * <pre>
     * The nLockTime field is useful for contracts.
     * </pre>
     *
     * <code>optional uint32 lock_time = 4;</code>
     * @param value The lockTime to set.
     */
    private void setLockTime(int value) {
      bitField0_ |= 0x00000008;
      lockTime_ = value;
    }
    /**
     * <pre>
     * The nLockTime field is useful for contracts.
     * </pre>
     *
     * <code>optional uint32 lock_time = 4;</code>
     */
    private void clearLockTime() {
      bitField0_ = (bitField0_ & ~0x00000008);
      lockTime_ = 0;
    }

    public static final int UPDATED_AT_FIELD_NUMBER = 5;
    private long updatedAt_;
    /**
     * <pre>
     * millis since epoch the transaction was last updated
     * </pre>
     *
     * <code>optional int64 updated_at = 5;</code>
     * @return Whether the updatedAt field is set.
     */
    @java.lang.Override
    public boolean hasUpdatedAt() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * millis since epoch the transaction was last updated
     * </pre>
     *
     * <code>optional int64 updated_at = 5;</code>
     * @return The updatedAt.
     */
    @java.lang.Override
    public long getUpdatedAt() {
      return updatedAt_;
    }
    /**
     * <pre>
     * millis since epoch the transaction was last updated
     * </pre>
     *
     * <code>optional int64 updated_at = 5;</code>
     * @param value The updatedAt to set.
     */
    private void setUpdatedAt(long value) {
      bitField0_ |= 0x00000010;
      updatedAt_ = value;
    }
    /**
     * <pre>
     * millis since epoch the transaction was last updated
     * </pre>
     *
     * <code>optional int64 updated_at = 5;</code>
     */
    private void clearUpdatedAt() {
      bitField0_ = (bitField0_ & ~0x00000010);
      updatedAt_ = 0L;
    }

    public static final int TRANSACTION_INPUT_FIELD_NUMBER = 6;
    private com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.TransactionInput> transactionInput_;
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    @java.lang.Override
    public java.util.List<org.bitcoinj.wallet.Protos.TransactionInput> getTransactionInputList() {
      return transactionInput_;
    }
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    public java.util.List<? extends org.bitcoinj.wallet.Protos.TransactionInputOrBuilder> 
        getTransactionInputOrBuilderList() {
      return transactionInput_;
    }
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    @java.lang.Override
    public int getTransactionInputCount() {
      return transactionInput_.size();
    }
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.TransactionInput getTransactionInput(int index) {
      return transactionInput_.get(index);
    }
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    public org.bitcoinj.wallet.Protos.TransactionInputOrBuilder getTransactionInputOrBuilder(
        int index) {
      return transactionInput_.get(index);
    }
    private void ensureTransactionInputIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.TransactionInput> tmp = transactionInput_;
      if (!tmp.isModifiable()) {
        transactionInput_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    private void setTransactionInput(
        int index, org.bitcoinj.wallet.Protos.TransactionInput value) {
      value.getClass();
  ensureTransactionInputIsMutable();
      transactionInput_.set(index, value);
    }
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    private void addTransactionInput(org.bitcoinj.wallet.Protos.TransactionInput value) {
      value.getClass();
  ensureTransactionInputIsMutable();
      transactionInput_.add(value);
    }
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    private void addTransactionInput(
        int index, org.bitcoinj.wallet.Protos.TransactionInput value) {
      value.getClass();
  ensureTransactionInputIsMutable();
      transactionInput_.add(index, value);
    }
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    private void addAllTransactionInput(
        java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.TransactionInput> values) {
      ensureTransactionInputIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, transactionInput_);
    }
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    private void clearTransactionInput() {
      transactionInput_ = emptyProtobufList();
    }
    /**
     * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
     */
    private void removeTransactionInput(int index) {
      ensureTransactionInputIsMutable();
      transactionInput_.remove(index);
    }

    public static final int TRANSACTION_OUTPUT_FIELD_NUMBER = 7;
    private com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.TransactionOutput> transactionOutput_;
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    @java.lang.Override
    public java.util.List<org.bitcoinj.wallet.Protos.TransactionOutput> getTransactionOutputList() {
      return transactionOutput_;
    }
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    public java.util.List<? extends org.bitcoinj.wallet.Protos.TransactionOutputOrBuilder> 
        getTransactionOutputOrBuilderList() {
      return transactionOutput_;
    }
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    @java.lang.Override
    public int getTransactionOutputCount() {
      return transactionOutput_.size();
    }
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.TransactionOutput getTransactionOutput(int index) {
      return transactionOutput_.get(index);
    }
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    public org.bitcoinj.wallet.Protos.TransactionOutputOrBuilder getTransactionOutputOrBuilder(
        int index) {
      return transactionOutput_.get(index);
    }
    private void ensureTransactionOutputIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.TransactionOutput> tmp = transactionOutput_;
      if (!tmp.isModifiable()) {
        transactionOutput_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    private void setTransactionOutput(
        int index, org.bitcoinj.wallet.Protos.TransactionOutput value) {
      value.getClass();
  ensureTransactionOutputIsMutable();
      transactionOutput_.set(index, value);
    }
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    private void addTransactionOutput(org.bitcoinj.wallet.Protos.TransactionOutput value) {
      value.getClass();
  ensureTransactionOutputIsMutable();
      transactionOutput_.add(value);
    }
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    private void addTransactionOutput(
        int index, org.bitcoinj.wallet.Protos.TransactionOutput value) {
      value.getClass();
  ensureTransactionOutputIsMutable();
      transactionOutput_.add(index, value);
    }
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    private void addAllTransactionOutput(
        java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.TransactionOutput> values) {
      ensureTransactionOutputIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, transactionOutput_);
    }
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    private void clearTransactionOutput() {
      transactionOutput_ = emptyProtobufList();
    }
    /**
     * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
     */
    private void removeTransactionOutput(int index) {
      ensureTransactionOutputIsMutable();
      transactionOutput_.remove(index);
    }

    public static final int BLOCK_HASH_FIELD_NUMBER = 8;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> blockHash_;
    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     * @return A list containing the blockHash.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getBlockHashList() {
      return blockHash_;
    }
    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     * @return The count of blockHash.
     */
    @java.lang.Override
    public int getBlockHashCount() {
      return blockHash_.size();
    }
    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     * @param index The index of the element to return.
     * @return The blockHash at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBlockHash(int index) {
      return blockHash_.get(index);
    }
    private void ensureBlockHashIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> tmp = blockHash_;
      if (!tmp.isModifiable()) {
        blockHash_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     * @param index The index to set the value at.
     * @param value The blockHash to set.
     */
    private void setBlockHash(
        int index, com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureBlockHashIsMutable();
      blockHash_.set(index, value);
    }
    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     * @param value The blockHash to add.
     */
    private void addBlockHash(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureBlockHashIsMutable();
      blockHash_.add(value);
    }
    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     * @param values The blockHash to add.
     */
    private void addAllBlockHash(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      ensureBlockHashIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, blockHash_);
    }
    /**
     * <pre>
     * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
     * ordering within a block.
     * </pre>
     *
     * <code>repeated bytes block_hash = 8;</code>
     */
    private void clearBlockHash() {
      blockHash_ = emptyProtobufList();
    }

    public static final int BLOCK_RELATIVITY_OFFSETS_FIELD_NUMBER = 11;
    private com.google.protobuf.Internal.IntList blockRelativityOffsets_;
    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     * @return A list containing the blockRelativityOffsets.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getBlockRelativityOffsetsList() {
      return blockRelativityOffsets_;
    }
    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     * @return The count of blockRelativityOffsets.
     */
    @java.lang.Override
    public int getBlockRelativityOffsetsCount() {
      return blockRelativityOffsets_.size();
    }
    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     * @param index The index of the element to return.
     * @return The blockRelativityOffsets at the given index.
     */
    @java.lang.Override
    public int getBlockRelativityOffsets(int index) {
      return blockRelativityOffsets_.getInt(index);
    }
    private void ensureBlockRelativityOffsetsIsMutable() {
      com.google.protobuf.Internal.IntList tmp = blockRelativityOffsets_;
      if (!tmp.isModifiable()) {
        blockRelativityOffsets_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     * @param index The index to set the value at.
     * @param value The blockRelativityOffsets to set.
     */
    private void setBlockRelativityOffsets(
        int index, int value) {
      ensureBlockRelativityOffsetsIsMutable();
      blockRelativityOffsets_.setInt(index, value);
    }
    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     * @param value The blockRelativityOffsets to add.
     */
    private void addBlockRelativityOffsets(int value) {
      ensureBlockRelativityOffsetsIsMutable();
      blockRelativityOffsets_.addInt(value);
    }
    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     * @param values The blockRelativityOffsets to add.
     */
    private void addAllBlockRelativityOffsets(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureBlockRelativityOffsetsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, blockRelativityOffsets_);
    }
    /**
     * <code>repeated int32 block_relativity_offsets = 11;</code>
     */
    private void clearBlockRelativityOffsets() {
      blockRelativityOffsets_ = emptyIntList();
    }

    public static final int CONFIDENCE_FIELD_NUMBER = 9;
    private org.bitcoinj.wallet.Protos.TransactionConfidence confidence_;
    /**
     * <pre>
     * Data describing where the transaction is in the chain.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
     */
    @java.lang.Override
    public boolean hasConfidence() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Data describing where the transaction is in the chain.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.TransactionConfidence getConfidence() {
      return confidence_ == null ? org.bitcoinj.wallet.Protos.TransactionConfidence.getDefaultInstance() : confidence_;
    }
    /**
     * <pre>
     * Data describing where the transaction is in the chain.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
     */
    private void setConfidence(org.bitcoinj.wallet.Protos.TransactionConfidence value) {
      value.getClass();
  confidence_ = value;
      bitField0_ |= 0x00000020;
      }
    /**
     * <pre>
     * Data describing where the transaction is in the chain.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeConfidence(org.bitcoinj.wallet.Protos.TransactionConfidence value) {
      value.getClass();
  if (confidence_ != null &&
          confidence_ != org.bitcoinj.wallet.Protos.TransactionConfidence.getDefaultInstance()) {
        confidence_ =
          org.bitcoinj.wallet.Protos.TransactionConfidence.newBuilder(confidence_).mergeFrom(value).buildPartial();
      } else {
        confidence_ = value;
      }
      bitField0_ |= 0x00000020;
    }
    /**
     * <pre>
     * Data describing where the transaction is in the chain.
     * </pre>
     *
     * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
     */
    private void clearConfidence() {  confidence_ = null;
      bitField0_ = (bitField0_ & ~0x00000020);
    }

    public static final int PURPOSE_FIELD_NUMBER = 10;
    private int purpose_;
    /**
     * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
     * @return Whether the purpose field is set.
     */
    @java.lang.Override
    public boolean hasPurpose() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
     * @return The purpose.
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Transaction.Purpose getPurpose() {
      org.bitcoinj.wallet.Protos.Transaction.Purpose result = org.bitcoinj.wallet.Protos.Transaction.Purpose.forNumber(purpose_);
      return result == null ? org.bitcoinj.wallet.Protos.Transaction.Purpose.UNKNOWN : result;
    }
    /**
     * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
     * @param value The purpose to set.
     */
    private void setPurpose(org.bitcoinj.wallet.Protos.Transaction.Purpose value) {
      purpose_ = value.getNumber();
      bitField0_ |= 0x00000040;
    }
    /**
     * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
     */
    private void clearPurpose() {
      bitField0_ = (bitField0_ & ~0x00000040);
      purpose_ = 0;
    }

    public static final int EXCHANGE_RATE_FIELD_NUMBER = 12;
    private org.bitcoinj.wallet.Protos.ExchangeRate exchangeRate_;
    /**
     * <pre>
     * Exchange rate that was valid when the transaction was sent.
     * </pre>
     *
     * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
     */
    @java.lang.Override
    public boolean hasExchangeRate() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Exchange rate that was valid when the transaction was sent.
     * </pre>
     *
     * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.ExchangeRate getExchangeRate() {
      return exchangeRate_ == null ? org.bitcoinj.wallet.Protos.ExchangeRate.getDefaultInstance() : exchangeRate_;
    }
    /**
     * <pre>
     * Exchange rate that was valid when the transaction was sent.
     * </pre>
     *
     * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
     */
    private void setExchangeRate(org.bitcoinj.wallet.Protos.ExchangeRate value) {
      value.getClass();
  exchangeRate_ = value;
      bitField0_ |= 0x00000080;
      }
    /**
     * <pre>
     * Exchange rate that was valid when the transaction was sent.
     * </pre>
     *
     * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeExchangeRate(org.bitcoinj.wallet.Protos.ExchangeRate value) {
      value.getClass();
  if (exchangeRate_ != null &&
          exchangeRate_ != org.bitcoinj.wallet.Protos.ExchangeRate.getDefaultInstance()) {
        exchangeRate_ =
          org.bitcoinj.wallet.Protos.ExchangeRate.newBuilder(exchangeRate_).mergeFrom(value).buildPartial();
      } else {
        exchangeRate_ = value;
      }
      bitField0_ |= 0x00000080;
    }
    /**
     * <pre>
     * Exchange rate that was valid when the transaction was sent.
     * </pre>
     *
     * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
     */
    private void clearExchangeRate() {  exchangeRate_ = null;
      bitField0_ = (bitField0_ & ~0x00000080);
    }

    public static final int MEMO_FIELD_NUMBER = 13;
    private java.lang.String memo_;
    /**
     * <pre>
     * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
     * transaction.
     * </pre>
     *
     * <code>optional string memo = 13;</code>
     * @return Whether the memo field is set.
     */
    @java.lang.Override
    public boolean hasMemo() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
     * transaction.
     * </pre>
     *
     * <code>optional string memo = 13;</code>
     * @return The memo.
     */
    @java.lang.Override
    public java.lang.String getMemo() {
      return memo_;
    }
    /**
     * <pre>
     * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
     * transaction.
     * </pre>
     *
     * <code>optional string memo = 13;</code>
     * @return The bytes for memo.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMemoBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(memo_);
    }
    /**
     * <pre>
     * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
     * transaction.
     * </pre>
     *
     * <code>optional string memo = 13;</code>
     * @param value The memo to set.
     */
    private void setMemo(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000100;
      memo_ = value;
    }
    /**
     * <pre>
     * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
     * transaction.
     * </pre>
     *
     * <code>optional string memo = 13;</code>
     */
    private void clearMemo() {
      bitField0_ = (bitField0_ & ~0x00000100);
      memo_ = getDefaultInstance().getMemo();
    }
    /**
     * <pre>
     * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
     * transaction.
     * </pre>
     *
     * <code>optional string memo = 13;</code>
     * @param value The bytes for memo to set.
     */
    private void setMemoBytes(
        com.google.protobuf.ByteString value) {
      memo_ = value.toStringUtf8();
      bitField0_ |= 0x00000100;
    }

    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Transaction parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.Transaction prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code wallet.Transaction}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.Transaction, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.Transaction)
        org.bitcoinj.wallet.Protos.TransactionOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.Transaction.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * See Wallet.java for detailed description of pool semantics
       * </pre>
       *
       * <code>required int32 version = 1;</code>
       * @return Whether the version field is set.
       */
      @java.lang.Override
      public boolean hasVersion() {
        return instance.hasVersion();
      }
      /**
       * <pre>
       * See Wallet.java for detailed description of pool semantics
       * </pre>
       *
       * <code>required int32 version = 1;</code>
       * @return The version.
       */
      @java.lang.Override
      public int getVersion() {
        return instance.getVersion();
      }
      /**
       * <pre>
       * See Wallet.java for detailed description of pool semantics
       * </pre>
       *
       * <code>required int32 version = 1;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(int value) {
        copyOnWrite();
        instance.setVersion(value);
        return this;
      }
      /**
       * <pre>
       * See Wallet.java for detailed description of pool semantics
       * </pre>
       *
       * <code>required int32 version = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        copyOnWrite();
        instance.clearVersion();
        return this;
      }

      /**
       * <code>required bytes hash = 2;</code>
       * @return Whether the hash field is set.
       */
      @java.lang.Override
      public boolean hasHash() {
        return instance.hasHash();
      }
      /**
       * <code>required bytes hash = 2;</code>
       * @return The hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHash() {
        return instance.getHash();
      }
      /**
       * <code>required bytes hash = 2;</code>
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setHash(value);
        return this;
      }
      /**
       * <code>required bytes hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        copyOnWrite();
        instance.clearHash();
        return this;
      }

      /**
       * <pre>
       * If pool is not present, that means either:
       *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
       *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
       *  - Or the Pool enum got a new value which your software is too old to parse.
       * </pre>
       *
       * <code>optional .wallet.Transaction.Pool pool = 3;</code>
       * @return Whether the pool field is set.
       */
      @java.lang.Override
      public boolean hasPool() {
        return instance.hasPool();
      }
      /**
       * <pre>
       * If pool is not present, that means either:
       *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
       *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
       *  - Or the Pool enum got a new value which your software is too old to parse.
       * </pre>
       *
       * <code>optional .wallet.Transaction.Pool pool = 3;</code>
       * @return The pool.
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Transaction.Pool getPool() {
        return instance.getPool();
      }
      /**
       * <pre>
       * If pool is not present, that means either:
       *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
       *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
       *  - Or the Pool enum got a new value which your software is too old to parse.
       * </pre>
       *
       * <code>optional .wallet.Transaction.Pool pool = 3;</code>
       * @param value The enum numeric value on the wire for pool to set.
       * @return This builder for chaining.
       */
      public Builder setPool(org.bitcoinj.wallet.Protos.Transaction.Pool value) {
        copyOnWrite();
        instance.setPool(value);
        return this;
      }
      /**
       * <pre>
       * If pool is not present, that means either:
       *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
       *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
       *  - Or the Pool enum got a new value which your software is too old to parse.
       * </pre>
       *
       * <code>optional .wallet.Transaction.Pool pool = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPool() {
        copyOnWrite();
        instance.clearPool();
        return this;
      }

      /**
       * <pre>
       * The nLockTime field is useful for contracts.
       * </pre>
       *
       * <code>optional uint32 lock_time = 4;</code>
       * @return Whether the lockTime field is set.
       */
      @java.lang.Override
      public boolean hasLockTime() {
        return instance.hasLockTime();
      }
      /**
       * <pre>
       * The nLockTime field is useful for contracts.
       * </pre>
       *
       * <code>optional uint32 lock_time = 4;</code>
       * @return The lockTime.
       */
      @java.lang.Override
      public int getLockTime() {
        return instance.getLockTime();
      }
      /**
       * <pre>
       * The nLockTime field is useful for contracts.
       * </pre>
       *
       * <code>optional uint32 lock_time = 4;</code>
       * @param value The lockTime to set.
       * @return This builder for chaining.
       */
      public Builder setLockTime(int value) {
        copyOnWrite();
        instance.setLockTime(value);
        return this;
      }
      /**
       * <pre>
       * The nLockTime field is useful for contracts.
       * </pre>
       *
       * <code>optional uint32 lock_time = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLockTime() {
        copyOnWrite();
        instance.clearLockTime();
        return this;
      }

      /**
       * <pre>
       * millis since epoch the transaction was last updated
       * </pre>
       *
       * <code>optional int64 updated_at = 5;</code>
       * @return Whether the updatedAt field is set.
       */
      @java.lang.Override
      public boolean hasUpdatedAt() {
        return instance.hasUpdatedAt();
      }
      /**
       * <pre>
       * millis since epoch the transaction was last updated
       * </pre>
       *
       * <code>optional int64 updated_at = 5;</code>
       * @return The updatedAt.
       */
      @java.lang.Override
      public long getUpdatedAt() {
        return instance.getUpdatedAt();
      }
      /**
       * <pre>
       * millis since epoch the transaction was last updated
       * </pre>
       *
       * <code>optional int64 updated_at = 5;</code>
       * @param value The updatedAt to set.
       * @return This builder for chaining.
       */
      public Builder setUpdatedAt(long value) {
        copyOnWrite();
        instance.setUpdatedAt(value);
        return this;
      }
      /**
       * <pre>
       * millis since epoch the transaction was last updated
       * </pre>
       *
       * <code>optional int64 updated_at = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpdatedAt() {
        copyOnWrite();
        instance.clearUpdatedAt();
        return this;
      }

      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      @java.lang.Override
      public java.util.List<org.bitcoinj.wallet.Protos.TransactionInput> getTransactionInputList() {
        return java.util.Collections.unmodifiableList(
            instance.getTransactionInputList());
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      @java.lang.Override
      public int getTransactionInputCount() {
        return instance.getTransactionInputCount();
      }/**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.TransactionInput getTransactionInput(int index) {
        return instance.getTransactionInput(index);
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      public Builder setTransactionInput(
          int index, org.bitcoinj.wallet.Protos.TransactionInput value) {
        copyOnWrite();
        instance.setTransactionInput(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      public Builder setTransactionInput(
          int index, org.bitcoinj.wallet.Protos.TransactionInput.Builder builderForValue) {
        copyOnWrite();
        instance.setTransactionInput(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      public Builder addTransactionInput(org.bitcoinj.wallet.Protos.TransactionInput value) {
        copyOnWrite();
        instance.addTransactionInput(value);
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      public Builder addTransactionInput(
          int index, org.bitcoinj.wallet.Protos.TransactionInput value) {
        copyOnWrite();
        instance.addTransactionInput(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      public Builder addTransactionInput(
          org.bitcoinj.wallet.Protos.TransactionInput.Builder builderForValue) {
        copyOnWrite();
        instance.addTransactionInput(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      public Builder addTransactionInput(
          int index, org.bitcoinj.wallet.Protos.TransactionInput.Builder builderForValue) {
        copyOnWrite();
        instance.addTransactionInput(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      public Builder addAllTransactionInput(
          java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.TransactionInput> values) {
        copyOnWrite();
        instance.addAllTransactionInput(values);
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      public Builder clearTransactionInput() {
        copyOnWrite();
        instance.clearTransactionInput();
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionInput transaction_input = 6;</code>
       */
      public Builder removeTransactionInput(int index) {
        copyOnWrite();
        instance.removeTransactionInput(index);
        return this;
      }

      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      @java.lang.Override
      public java.util.List<org.bitcoinj.wallet.Protos.TransactionOutput> getTransactionOutputList() {
        return java.util.Collections.unmodifiableList(
            instance.getTransactionOutputList());
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      @java.lang.Override
      public int getTransactionOutputCount() {
        return instance.getTransactionOutputCount();
      }/**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.TransactionOutput getTransactionOutput(int index) {
        return instance.getTransactionOutput(index);
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      public Builder setTransactionOutput(
          int index, org.bitcoinj.wallet.Protos.TransactionOutput value) {
        copyOnWrite();
        instance.setTransactionOutput(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      public Builder setTransactionOutput(
          int index, org.bitcoinj.wallet.Protos.TransactionOutput.Builder builderForValue) {
        copyOnWrite();
        instance.setTransactionOutput(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      public Builder addTransactionOutput(org.bitcoinj.wallet.Protos.TransactionOutput value) {
        copyOnWrite();
        instance.addTransactionOutput(value);
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      public Builder addTransactionOutput(
          int index, org.bitcoinj.wallet.Protos.TransactionOutput value) {
        copyOnWrite();
        instance.addTransactionOutput(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      public Builder addTransactionOutput(
          org.bitcoinj.wallet.Protos.TransactionOutput.Builder builderForValue) {
        copyOnWrite();
        instance.addTransactionOutput(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      public Builder addTransactionOutput(
          int index, org.bitcoinj.wallet.Protos.TransactionOutput.Builder builderForValue) {
        copyOnWrite();
        instance.addTransactionOutput(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      public Builder addAllTransactionOutput(
          java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.TransactionOutput> values) {
        copyOnWrite();
        instance.addAllTransactionOutput(values);
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      public Builder clearTransactionOutput() {
        copyOnWrite();
        instance.clearTransactionOutput();
        return this;
      }
      /**
       * <code>repeated .wallet.TransactionOutput transaction_output = 7;</code>
       */
      public Builder removeTransactionOutput(int index) {
        copyOnWrite();
        instance.removeTransactionOutput(index);
        return this;
      }

      /**
       * <pre>
       * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
       * ordering within a block.
       * </pre>
       *
       * <code>repeated bytes block_hash = 8;</code>
       * @return A list containing the blockHash.
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.ByteString>
          getBlockHashList() {
        return java.util.Collections.unmodifiableList(
            instance.getBlockHashList());
      }
      /**
       * <pre>
       * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
       * ordering within a block.
       * </pre>
       *
       * <code>repeated bytes block_hash = 8;</code>
       * @return The count of blockHash.
       */
      @java.lang.Override
      public int getBlockHashCount() {
        return instance.getBlockHashCount();
      }
      /**
       * <pre>
       * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
       * ordering within a block.
       * </pre>
       *
       * <code>repeated bytes block_hash = 8;</code>
       * @param index The index of the element to return.
       * @return The blockHash at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBlockHash(int index) {
        return instance.getBlockHash(index);
      }
      /**
       * <pre>
       * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
       * ordering within a block.
       * </pre>
       *
       * <code>repeated bytes block_hash = 8;</code>
       * @param value The blockHash to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHash(
          int index, com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setBlockHash(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
       * ordering within a block.
       * </pre>
       *
       * <code>repeated bytes block_hash = 8;</code>
       * @param value The blockHash to add.
       * @return This builder for chaining.
       */
      public Builder addBlockHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addBlockHash(value);
        return this;
      }
      /**
       * <pre>
       * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
       * ordering within a block.
       * </pre>
       *
       * <code>repeated bytes block_hash = 8;</code>
       * @param values The blockHash to add.
       * @return This builder for chaining.
       */
      public Builder addAllBlockHash(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.addAllBlockHash(values);
        return this;
      }
      /**
       * <pre>
       * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
       * ordering within a block.
       * </pre>
       *
       * <code>repeated bytes block_hash = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockHash() {
        copyOnWrite();
        instance.clearBlockHash();
        return this;
      }

      /**
       * <code>repeated int32 block_relativity_offsets = 11;</code>
       * @return A list containing the blockRelativityOffsets.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getBlockRelativityOffsetsList() {
        return java.util.Collections.unmodifiableList(
            instance.getBlockRelativityOffsetsList());
      }
      /**
       * <code>repeated int32 block_relativity_offsets = 11;</code>
       * @return The count of blockRelativityOffsets.
       */
      @java.lang.Override
      public int getBlockRelativityOffsetsCount() {
        return instance.getBlockRelativityOffsetsCount();
      }
      /**
       * <code>repeated int32 block_relativity_offsets = 11;</code>
       * @param index The index of the element to return.
       * @return The blockRelativityOffsets at the given index.
       */
      @java.lang.Override
      public int getBlockRelativityOffsets(int index) {
        return instance.getBlockRelativityOffsets(index);
      }
      /**
       * <code>repeated int32 block_relativity_offsets = 11;</code>
       * @param value The blockRelativityOffsets to set.
       * @return This builder for chaining.
       */
      public Builder setBlockRelativityOffsets(
          int index, int value) {
        copyOnWrite();
        instance.setBlockRelativityOffsets(index, value);
        return this;
      }
      /**
       * <code>repeated int32 block_relativity_offsets = 11;</code>
       * @param value The blockRelativityOffsets to add.
       * @return This builder for chaining.
       */
      public Builder addBlockRelativityOffsets(int value) {
        copyOnWrite();
        instance.addBlockRelativityOffsets(value);
        return this;
      }
      /**
       * <code>repeated int32 block_relativity_offsets = 11;</code>
       * @param values The blockRelativityOffsets to add.
       * @return This builder for chaining.
       */
      public Builder addAllBlockRelativityOffsets(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllBlockRelativityOffsets(values);
        return this;
      }
      /**
       * <code>repeated int32 block_relativity_offsets = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockRelativityOffsets() {
        copyOnWrite();
        instance.clearBlockRelativityOffsets();
        return this;
      }

      /**
       * <pre>
       * Data describing where the transaction is in the chain.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
       */
      @java.lang.Override
      public boolean hasConfidence() {
        return instance.hasConfidence();
      }
      /**
       * <pre>
       * Data describing where the transaction is in the chain.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.TransactionConfidence getConfidence() {
        return instance.getConfidence();
      }
      /**
       * <pre>
       * Data describing where the transaction is in the chain.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
       */
      public Builder setConfidence(org.bitcoinj.wallet.Protos.TransactionConfidence value) {
        copyOnWrite();
        instance.setConfidence(value);
        return this;
        }
      /**
       * <pre>
       * Data describing where the transaction is in the chain.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
       */
      public Builder setConfidence(
          org.bitcoinj.wallet.Protos.TransactionConfidence.Builder builderForValue) {
        copyOnWrite();
        instance.setConfidence(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Data describing where the transaction is in the chain.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
       */
      public Builder mergeConfidence(org.bitcoinj.wallet.Protos.TransactionConfidence value) {
        copyOnWrite();
        instance.mergeConfidence(value);
        return this;
      }
      /**
       * <pre>
       * Data describing where the transaction is in the chain.
       * </pre>
       *
       * <code>optional .wallet.TransactionConfidence confidence = 9;</code>
       */
      public Builder clearConfidence() {  copyOnWrite();
        instance.clearConfidence();
        return this;
      }

      /**
       * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
       * @return Whether the purpose field is set.
       */
      @java.lang.Override
      public boolean hasPurpose() {
        return instance.hasPurpose();
      }
      /**
       * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
       * @return The purpose.
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Transaction.Purpose getPurpose() {
        return instance.getPurpose();
      }
      /**
       * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
       * @param value The enum numeric value on the wire for purpose to set.
       * @return This builder for chaining.
       */
      public Builder setPurpose(org.bitcoinj.wallet.Protos.Transaction.Purpose value) {
        copyOnWrite();
        instance.setPurpose(value);
        return this;
      }
      /**
       * <code>optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];</code>
       * @return This builder for chaining.
       */
      public Builder clearPurpose() {
        copyOnWrite();
        instance.clearPurpose();
        return this;
      }

      /**
       * <pre>
       * Exchange rate that was valid when the transaction was sent.
       * </pre>
       *
       * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
       */
      @java.lang.Override
      public boolean hasExchangeRate() {
        return instance.hasExchangeRate();
      }
      /**
       * <pre>
       * Exchange rate that was valid when the transaction was sent.
       * </pre>
       *
       * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.ExchangeRate getExchangeRate() {
        return instance.getExchangeRate();
      }
      /**
       * <pre>
       * Exchange rate that was valid when the transaction was sent.
       * </pre>
       *
       * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
       */
      public Builder setExchangeRate(org.bitcoinj.wallet.Protos.ExchangeRate value) {
        copyOnWrite();
        instance.setExchangeRate(value);
        return this;
        }
      /**
       * <pre>
       * Exchange rate that was valid when the transaction was sent.
       * </pre>
       *
       * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
       */
      public Builder setExchangeRate(
          org.bitcoinj.wallet.Protos.ExchangeRate.Builder builderForValue) {
        copyOnWrite();
        instance.setExchangeRate(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Exchange rate that was valid when the transaction was sent.
       * </pre>
       *
       * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
       */
      public Builder mergeExchangeRate(org.bitcoinj.wallet.Protos.ExchangeRate value) {
        copyOnWrite();
        instance.mergeExchangeRate(value);
        return this;
      }
      /**
       * <pre>
       * Exchange rate that was valid when the transaction was sent.
       * </pre>
       *
       * <code>optional .wallet.ExchangeRate exchange_rate = 12;</code>
       */
      public Builder clearExchangeRate() {  copyOnWrite();
        instance.clearExchangeRate();
        return this;
      }

      /**
       * <pre>
       * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
       * transaction.
       * </pre>
       *
       * <code>optional string memo = 13;</code>
       * @return Whether the memo field is set.
       */
      @java.lang.Override
      public boolean hasMemo() {
        return instance.hasMemo();
      }
      /**
       * <pre>
       * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
       * transaction.
       * </pre>
       *
       * <code>optional string memo = 13;</code>
       * @return The memo.
       */
      @java.lang.Override
      public java.lang.String getMemo() {
        return instance.getMemo();
      }
      /**
       * <pre>
       * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
       * transaction.
       * </pre>
       *
       * <code>optional string memo = 13;</code>
       * @return The bytes for memo.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMemoBytes() {
        return instance.getMemoBytes();
      }
      /**
       * <pre>
       * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
       * transaction.
       * </pre>
       *
       * <code>optional string memo = 13;</code>
       * @param value The memo to set.
       * @return This builder for chaining.
       */
      public Builder setMemo(
          java.lang.String value) {
        copyOnWrite();
        instance.setMemo(value);
        return this;
      }
      /**
       * <pre>
       * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
       * transaction.
       * </pre>
       *
       * <code>optional string memo = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearMemo() {
        copyOnWrite();
        instance.clearMemo();
        return this;
      }
      /**
       * <pre>
       * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
       * transaction.
       * </pre>
       *
       * <code>optional string memo = 13;</code>
       * @param value The bytes for memo to set.
       * @return This builder for chaining.
       */
      public Builder setMemoBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMemoBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.Transaction)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.Transaction();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "version_",
              "hash_",
              "pool_",
              org.bitcoinj.wallet.Protos.Transaction.Pool.internalGetVerifier(),
              "lockTime_",
              "updatedAt_",
              "transactionInput_",
              org.bitcoinj.wallet.Protos.TransactionInput.class,
              "transactionOutput_",
              org.bitcoinj.wallet.Protos.TransactionOutput.class,
              "blockHash_",
              "confidence_",
              "purpose_",
              org.bitcoinj.wallet.Protos.Transaction.Purpose.internalGetVerifier(),
              "blockRelativityOffsets_",
              "exchangeRate_",
              "memo_",
            };
            java.lang.String info =
                "\u0001\r\u0000\u0001\u0001\r\r\u0000\u0004\u0006\u0001\u1504\u0000\u0002\u150a\u0001" +
                "\u0003\u100c\u0002\u0004\u100b\u0003\u0005\u1002\u0004\u0006\u041b\u0007\u041b\b" +
                "\u001c\t\u1409\u0005\n\u100c\u0006\u000b\u0016\f\u1409\u0007\r\u1008\b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.Transaction> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.Transaction.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.Transaction>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.Transaction)
    private static final org.bitcoinj.wallet.Protos.Transaction DEFAULT_INSTANCE;
    static {
      Transaction defaultInstance = new Transaction();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Transaction.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.Transaction getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Transaction> PARSER;

    public static com.google.protobuf.Parser<Transaction> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ScryptParametersOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.ScryptParameters)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Salt to use in generation of the wallet password (8 bytes)
     * </pre>
     *
     * <code>required bytes salt = 1;</code>
     * @return Whether the salt field is set.
     */
    boolean hasSalt();
    /**
     * <pre>
     * Salt to use in generation of the wallet password (8 bytes)
     * </pre>
     *
     * <code>required bytes salt = 1;</code>
     * @return The salt.
     */
    com.google.protobuf.ByteString getSalt();

    /**
     * <pre>
     * CPU/ memory cost parameter
     * </pre>
     *
     * <code>optional int64 n = 2 [default = 16384];</code>
     * @return Whether the n field is set.
     */
    boolean hasN();
    /**
     * <pre>
     * CPU/ memory cost parameter
     * </pre>
     *
     * <code>optional int64 n = 2 [default = 16384];</code>
     * @return The n.
     */
    long getN();

    /**
     * <pre>
     * Block size parameter
     * </pre>
     *
     * <code>optional int32 r = 3 [default = 8];</code>
     * @return Whether the r field is set.
     */
    boolean hasR();
    /**
     * <pre>
     * Block size parameter
     * </pre>
     *
     * <code>optional int32 r = 3 [default = 8];</code>
     * @return The r.
     */
    int getR();

    /**
     * <pre>
     * Parallelisation parameter
     * </pre>
     *
     * <code>optional int32 p = 4 [default = 1];</code>
     * @return Whether the p field is set.
     */
    boolean hasP();
    /**
     * <pre>
     * Parallelisation parameter
     * </pre>
     *
     * <code>optional int32 p = 4 [default = 1];</code>
     * @return The p.
     */
    int getP();
  }
  /**
   * <pre>
   ** The parameters used in the scrypt key derivation function.
   *  The default values are taken from http://www.tarsnap.com/scrypt/scrypt-slides.pdf.
   *  They can be increased - n is the number of iterations performed and
   *  r and p can be used to tweak the algorithm - see:
   *  http://stackoverflow.com/questions/11126315/what-are-optimal-scrypt-work-factors
   * </pre>
   *
   * Protobuf type {@code wallet.ScryptParameters}
   */
  public  static final class ScryptParameters extends
      com.google.protobuf.GeneratedMessageLite<
          ScryptParameters, ScryptParameters.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.ScryptParameters)
      ScryptParametersOrBuilder {
    private ScryptParameters() {
      salt_ = com.google.protobuf.ByteString.EMPTY;
      n_ = 16384L;
      r_ = 8;
      p_ = 1;
    }
    private int bitField0_;
    public static final int SALT_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString salt_;
    /**
     * <pre>
     * Salt to use in generation of the wallet password (8 bytes)
     * </pre>
     *
     * <code>required bytes salt = 1;</code>
     * @return Whether the salt field is set.
     */
    @java.lang.Override
    public boolean hasSalt() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Salt to use in generation of the wallet password (8 bytes)
     * </pre>
     *
     * <code>required bytes salt = 1;</code>
     * @return The salt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSalt() {
      return salt_;
    }
    /**
     * <pre>
     * Salt to use in generation of the wallet password (8 bytes)
     * </pre>
     *
     * <code>required bytes salt = 1;</code>
     * @param value The salt to set.
     */
    private void setSalt(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      salt_ = value;
    }
    /**
     * <pre>
     * Salt to use in generation of the wallet password (8 bytes)
     * </pre>
     *
     * <code>required bytes salt = 1;</code>
     */
    private void clearSalt() {
      bitField0_ = (bitField0_ & ~0x00000001);
      salt_ = getDefaultInstance().getSalt();
    }

    public static final int N_FIELD_NUMBER = 2;
    private long n_;
    /**
     * <pre>
     * CPU/ memory cost parameter
     * </pre>
     *
     * <code>optional int64 n = 2 [default = 16384];</code>
     * @return Whether the n field is set.
     */
    @java.lang.Override
    public boolean hasN() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * CPU/ memory cost parameter
     * </pre>
     *
     * <code>optional int64 n = 2 [default = 16384];</code>
     * @return The n.
     */
    @java.lang.Override
    public long getN() {
      return n_;
    }
    /**
     * <pre>
     * CPU/ memory cost parameter
     * </pre>
     *
     * <code>optional int64 n = 2 [default = 16384];</code>
     * @param value The n to set.
     */
    private void setN(long value) {
      bitField0_ |= 0x00000002;
      n_ = value;
    }
    /**
     * <pre>
     * CPU/ memory cost parameter
     * </pre>
     *
     * <code>optional int64 n = 2 [default = 16384];</code>
     */
    private void clearN() {
      bitField0_ = (bitField0_ & ~0x00000002);
      n_ = 16384L;
    }

    public static final int R_FIELD_NUMBER = 3;
    private int r_;
    /**
     * <pre>
     * Block size parameter
     * </pre>
     *
     * <code>optional int32 r = 3 [default = 8];</code>
     * @return Whether the r field is set.
     */
    @java.lang.Override
    public boolean hasR() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Block size parameter
     * </pre>
     *
     * <code>optional int32 r = 3 [default = 8];</code>
     * @return The r.
     */
    @java.lang.Override
    public int getR() {
      return r_;
    }
    /**
     * <pre>
     * Block size parameter
     * </pre>
     *
     * <code>optional int32 r = 3 [default = 8];</code>
     * @param value The r to set.
     */
    private void setR(int value) {
      bitField0_ |= 0x00000004;
      r_ = value;
    }
    /**
     * <pre>
     * Block size parameter
     * </pre>
     *
     * <code>optional int32 r = 3 [default = 8];</code>
     */
    private void clearR() {
      bitField0_ = (bitField0_ & ~0x00000004);
      r_ = 8;
    }

    public static final int P_FIELD_NUMBER = 4;
    private int p_;
    /**
     * <pre>
     * Parallelisation parameter
     * </pre>
     *
     * <code>optional int32 p = 4 [default = 1];</code>
     * @return Whether the p field is set.
     */
    @java.lang.Override
    public boolean hasP() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Parallelisation parameter
     * </pre>
     *
     * <code>optional int32 p = 4 [default = 1];</code>
     * @return The p.
     */
    @java.lang.Override
    public int getP() {
      return p_;
    }
    /**
     * <pre>
     * Parallelisation parameter
     * </pre>
     *
     * <code>optional int32 p = 4 [default = 1];</code>
     * @param value The p to set.
     */
    private void setP(int value) {
      bitField0_ |= 0x00000008;
      p_ = value;
    }
    /**
     * <pre>
     * Parallelisation parameter
     * </pre>
     *
     * <code>optional int32 p = 4 [default = 1];</code>
     */
    private void clearP() {
      bitField0_ = (bitField0_ & ~0x00000008);
      p_ = 1;
    }

    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.ScryptParameters parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.ScryptParameters prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     ** The parameters used in the scrypt key derivation function.
     *  The default values are taken from http://www.tarsnap.com/scrypt/scrypt-slides.pdf.
     *  They can be increased - n is the number of iterations performed and
     *  r and p can be used to tweak the algorithm - see:
     *  http://stackoverflow.com/questions/11126315/what-are-optimal-scrypt-work-factors
     * </pre>
     *
     * Protobuf type {@code wallet.ScryptParameters}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.ScryptParameters, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.ScryptParameters)
        org.bitcoinj.wallet.Protos.ScryptParametersOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.ScryptParameters.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Salt to use in generation of the wallet password (8 bytes)
       * </pre>
       *
       * <code>required bytes salt = 1;</code>
       * @return Whether the salt field is set.
       */
      @java.lang.Override
      public boolean hasSalt() {
        return instance.hasSalt();
      }
      /**
       * <pre>
       * Salt to use in generation of the wallet password (8 bytes)
       * </pre>
       *
       * <code>required bytes salt = 1;</code>
       * @return The salt.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSalt() {
        return instance.getSalt();
      }
      /**
       * <pre>
       * Salt to use in generation of the wallet password (8 bytes)
       * </pre>
       *
       * <code>required bytes salt = 1;</code>
       * @param value The salt to set.
       * @return This builder for chaining.
       */
      public Builder setSalt(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSalt(value);
        return this;
      }
      /**
       * <pre>
       * Salt to use in generation of the wallet password (8 bytes)
       * </pre>
       *
       * <code>required bytes salt = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSalt() {
        copyOnWrite();
        instance.clearSalt();
        return this;
      }

      /**
       * <pre>
       * CPU/ memory cost parameter
       * </pre>
       *
       * <code>optional int64 n = 2 [default = 16384];</code>
       * @return Whether the n field is set.
       */
      @java.lang.Override
      public boolean hasN() {
        return instance.hasN();
      }
      /**
       * <pre>
       * CPU/ memory cost parameter
       * </pre>
       *
       * <code>optional int64 n = 2 [default = 16384];</code>
       * @return The n.
       */
      @java.lang.Override
      public long getN() {
        return instance.getN();
      }
      /**
       * <pre>
       * CPU/ memory cost parameter
       * </pre>
       *
       * <code>optional int64 n = 2 [default = 16384];</code>
       * @param value The n to set.
       * @return This builder for chaining.
       */
      public Builder setN(long value) {
        copyOnWrite();
        instance.setN(value);
        return this;
      }
      /**
       * <pre>
       * CPU/ memory cost parameter
       * </pre>
       *
       * <code>optional int64 n = 2 [default = 16384];</code>
       * @return This builder for chaining.
       */
      public Builder clearN() {
        copyOnWrite();
        instance.clearN();
        return this;
      }

      /**
       * <pre>
       * Block size parameter
       * </pre>
       *
       * <code>optional int32 r = 3 [default = 8];</code>
       * @return Whether the r field is set.
       */
      @java.lang.Override
      public boolean hasR() {
        return instance.hasR();
      }
      /**
       * <pre>
       * Block size parameter
       * </pre>
       *
       * <code>optional int32 r = 3 [default = 8];</code>
       * @return The r.
       */
      @java.lang.Override
      public int getR() {
        return instance.getR();
      }
      /**
       * <pre>
       * Block size parameter
       * </pre>
       *
       * <code>optional int32 r = 3 [default = 8];</code>
       * @param value The r to set.
       * @return This builder for chaining.
       */
      public Builder setR(int value) {
        copyOnWrite();
        instance.setR(value);
        return this;
      }
      /**
       * <pre>
       * Block size parameter
       * </pre>
       *
       * <code>optional int32 r = 3 [default = 8];</code>
       * @return This builder for chaining.
       */
      public Builder clearR() {
        copyOnWrite();
        instance.clearR();
        return this;
      }

      /**
       * <pre>
       * Parallelisation parameter
       * </pre>
       *
       * <code>optional int32 p = 4 [default = 1];</code>
       * @return Whether the p field is set.
       */
      @java.lang.Override
      public boolean hasP() {
        return instance.hasP();
      }
      /**
       * <pre>
       * Parallelisation parameter
       * </pre>
       *
       * <code>optional int32 p = 4 [default = 1];</code>
       * @return The p.
       */
      @java.lang.Override
      public int getP() {
        return instance.getP();
      }
      /**
       * <pre>
       * Parallelisation parameter
       * </pre>
       *
       * <code>optional int32 p = 4 [default = 1];</code>
       * @param value The p to set.
       * @return This builder for chaining.
       */
      public Builder setP(int value) {
        copyOnWrite();
        instance.setP(value);
        return this;
      }
      /**
       * <pre>
       * Parallelisation parameter
       * </pre>
       *
       * <code>optional int32 p = 4 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearP() {
        copyOnWrite();
        instance.clearP();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.ScryptParameters)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.ScryptParameters();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "salt_",
              "n_",
              "r_",
              "p_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0000\u0001\u0001\u150a\u0000\u0002" +
                "\u1002\u0001\u0003\u1004\u0002\u0004\u1004\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.ScryptParameters> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.ScryptParameters.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.ScryptParameters>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.ScryptParameters)
    private static final org.bitcoinj.wallet.Protos.ScryptParameters DEFAULT_INSTANCE;
    static {
      ScryptParameters defaultInstance = new ScryptParameters();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ScryptParameters.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.ScryptParameters getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ScryptParameters> PARSER;

    public static com.google.protobuf.Parser<ScryptParameters> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ExtensionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.Extension)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * like org.whatever.foo.bar
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <pre>
     * like org.whatever.foo.bar
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return The id.
     */
    java.lang.String getId();
    /**
     * <pre>
     * like org.whatever.foo.bar
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return The bytes for id.
     */
    com.google.protobuf.ByteString
        getIdBytes();

    /**
     * <code>required bytes data = 2;</code>
     * @return Whether the data field is set.
     */
    boolean hasData();
    /**
     * <code>required bytes data = 2;</code>
     * @return The data.
     */
    com.google.protobuf.ByteString getData();

    /**
     * <pre>
     * If we do not understand a mandatory extension, abort to prevent data loss.
     * For example, this could be applied to a new type of holding, such as a contract, where
     * dropping of an extension in a read/write cycle could cause loss of value.
     * </pre>
     *
     * <code>required bool mandatory = 3;</code>
     * @return Whether the mandatory field is set.
     */
    boolean hasMandatory();
    /**
     * <pre>
     * If we do not understand a mandatory extension, abort to prevent data loss.
     * For example, this could be applied to a new type of holding, such as a contract, where
     * dropping of an extension in a read/write cycle could cause loss of value.
     * </pre>
     *
     * <code>required bool mandatory = 3;</code>
     * @return The mandatory.
     */
    boolean getMandatory();
  }
  /**
   * <pre>
   ** An extension to the wallet 
   * </pre>
   *
   * Protobuf type {@code wallet.Extension}
   */
  public  static final class Extension extends
      com.google.protobuf.GeneratedMessageLite<
          Extension, Extension.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.Extension)
      ExtensionOrBuilder {
    private Extension() {
      id_ = "";
      data_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int ID_FIELD_NUMBER = 1;
    private java.lang.String id_;
    /**
     * <pre>
     * like org.whatever.foo.bar
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * like org.whatever.foo.bar
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return The id.
     */
    @java.lang.Override
    public java.lang.String getId() {
      return id_;
    }
    /**
     * <pre>
     * like org.whatever.foo.bar
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @return The bytes for id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(id_);
    }
    /**
     * <pre>
     * like org.whatever.foo.bar
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @param value The id to set.
     */
    private void setId(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      id_ = value;
    }
    /**
     * <pre>
     * like org.whatever.foo.bar
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    private void clearId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      id_ = getDefaultInstance().getId();
    }
    /**
     * <pre>
     * like org.whatever.foo.bar
     * </pre>
     *
     * <code>required string id = 1;</code>
     * @param value The bytes for id to set.
     */
    private void setIdBytes(
        com.google.protobuf.ByteString value) {
      id_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int DATA_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString data_;
    /**
     * <code>required bytes data = 2;</code>
     * @return Whether the data field is set.
     */
    @java.lang.Override
    public boolean hasData() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>required bytes data = 2;</code>
     * @return The data.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getData() {
      return data_;
    }
    /**
     * <code>required bytes data = 2;</code>
     * @param value The data to set.
     */
    private void setData(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      data_ = value;
    }
    /**
     * <code>required bytes data = 2;</code>
     */
    private void clearData() {
      bitField0_ = (bitField0_ & ~0x00000002);
      data_ = getDefaultInstance().getData();
    }

    public static final int MANDATORY_FIELD_NUMBER = 3;
    private boolean mandatory_;
    /**
     * <pre>
     * If we do not understand a mandatory extension, abort to prevent data loss.
     * For example, this could be applied to a new type of holding, such as a contract, where
     * dropping of an extension in a read/write cycle could cause loss of value.
     * </pre>
     *
     * <code>required bool mandatory = 3;</code>
     * @return Whether the mandatory field is set.
     */
    @java.lang.Override
    public boolean hasMandatory() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If we do not understand a mandatory extension, abort to prevent data loss.
     * For example, this could be applied to a new type of holding, such as a contract, where
     * dropping of an extension in a read/write cycle could cause loss of value.
     * </pre>
     *
     * <code>required bool mandatory = 3;</code>
     * @return The mandatory.
     */
    @java.lang.Override
    public boolean getMandatory() {
      return mandatory_;
    }
    /**
     * <pre>
     * If we do not understand a mandatory extension, abort to prevent data loss.
     * For example, this could be applied to a new type of holding, such as a contract, where
     * dropping of an extension in a read/write cycle could cause loss of value.
     * </pre>
     *
     * <code>required bool mandatory = 3;</code>
     * @param value The mandatory to set.
     */
    private void setMandatory(boolean value) {
      bitField0_ |= 0x00000004;
      mandatory_ = value;
    }
    /**
     * <pre>
     * If we do not understand a mandatory extension, abort to prevent data loss.
     * For example, this could be applied to a new type of holding, such as a contract, where
     * dropping of an extension in a read/write cycle could cause loss of value.
     * </pre>
     *
     * <code>required bool mandatory = 3;</code>
     */
    private void clearMandatory() {
      bitField0_ = (bitField0_ & ~0x00000004);
      mandatory_ = false;
    }

    public static org.bitcoinj.wallet.Protos.Extension parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Extension parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.Extension prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     ** An extension to the wallet 
     * </pre>
     *
     * Protobuf type {@code wallet.Extension}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.Extension, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.Extension)
        org.bitcoinj.wallet.Protos.ExtensionOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.Extension.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * like org.whatever.foo.bar
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @return Whether the id field is set.
       */
      @java.lang.Override
      public boolean hasId() {
        return instance.hasId();
      }
      /**
       * <pre>
       * like org.whatever.foo.bar
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @return The id.
       */
      @java.lang.Override
      public java.lang.String getId() {
        return instance.getId();
      }
      /**
       * <pre>
       * like org.whatever.foo.bar
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @return The bytes for id.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getIdBytes() {
        return instance.getIdBytes();
      }
      /**
       * <pre>
       * like org.whatever.foo.bar
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(
          java.lang.String value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <pre>
       * like org.whatever.foo.bar
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }
      /**
       * <pre>
       * like org.whatever.foo.bar
       * </pre>
       *
       * <code>required string id = 1;</code>
       * @param value The bytes for id to set.
       * @return This builder for chaining.
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIdBytes(value);
        return this;
      }

      /**
       * <code>required bytes data = 2;</code>
       * @return Whether the data field is set.
       */
      @java.lang.Override
      public boolean hasData() {
        return instance.hasData();
      }
      /**
       * <code>required bytes data = 2;</code>
       * @return The data.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getData() {
        return instance.getData();
      }
      /**
       * <code>required bytes data = 2;</code>
       * @param value The data to set.
       * @return This builder for chaining.
       */
      public Builder setData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setData(value);
        return this;
      }
      /**
       * <code>required bytes data = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearData() {
        copyOnWrite();
        instance.clearData();
        return this;
      }

      /**
       * <pre>
       * If we do not understand a mandatory extension, abort to prevent data loss.
       * For example, this could be applied to a new type of holding, such as a contract, where
       * dropping of an extension in a read/write cycle could cause loss of value.
       * </pre>
       *
       * <code>required bool mandatory = 3;</code>
       * @return Whether the mandatory field is set.
       */
      @java.lang.Override
      public boolean hasMandatory() {
        return instance.hasMandatory();
      }
      /**
       * <pre>
       * If we do not understand a mandatory extension, abort to prevent data loss.
       * For example, this could be applied to a new type of holding, such as a contract, where
       * dropping of an extension in a read/write cycle could cause loss of value.
       * </pre>
       *
       * <code>required bool mandatory = 3;</code>
       * @return The mandatory.
       */
      @java.lang.Override
      public boolean getMandatory() {
        return instance.getMandatory();
      }
      /**
       * <pre>
       * If we do not understand a mandatory extension, abort to prevent data loss.
       * For example, this could be applied to a new type of holding, such as a contract, where
       * dropping of an extension in a read/write cycle could cause loss of value.
       * </pre>
       *
       * <code>required bool mandatory = 3;</code>
       * @param value The mandatory to set.
       * @return This builder for chaining.
       */
      public Builder setMandatory(boolean value) {
        copyOnWrite();
        instance.setMandatory(value);
        return this;
      }
      /**
       * <pre>
       * If we do not understand a mandatory extension, abort to prevent data loss.
       * For example, this could be applied to a new type of holding, such as a contract, where
       * dropping of an extension in a read/write cycle could cause loss of value.
       * </pre>
       *
       * <code>required bool mandatory = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearMandatory() {
        copyOnWrite();
        instance.clearMandatory();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.Extension)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.Extension();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "id_",
              "data_",
              "mandatory_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0003\u0001\u1508\u0000\u0002" +
                "\u150a\u0001\u0003\u1507\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.Extension> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.Extension.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.Extension>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.Extension)
    private static final org.bitcoinj.wallet.Protos.Extension DEFAULT_INSTANCE;
    static {
      Extension defaultInstance = new Extension();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Extension.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.Extension getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Extension> PARSER;

    public static com.google.protobuf.Parser<Extension> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TagOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.Tag)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required string tag = 1;</code>
     * @return Whether the tag field is set.
     */
    boolean hasTag();
    /**
     * <code>required string tag = 1;</code>
     * @return The tag.
     */
    java.lang.String getTag();
    /**
     * <code>required string tag = 1;</code>
     * @return The bytes for tag.
     */
    com.google.protobuf.ByteString
        getTagBytes();

    /**
     * <code>required bytes data = 2;</code>
     * @return Whether the data field is set.
     */
    boolean hasData();
    /**
     * <code>required bytes data = 2;</code>
     * @return The data.
     */
    com.google.protobuf.ByteString getData();
  }
  /**
   * <pre>
   **
   * A simple key-&gt;value mapping that has no interpreted content at all. A bit like the extensions mechanism except
   * an extension is keyed by the ID of a piece of code that's loaded with the given data, and has the concept of
   * being mandatory if that code isn't found. Whereas this is just a blind key/value store.
   * </pre>
   *
   * Protobuf type {@code wallet.Tag}
   */
  public  static final class Tag extends
      com.google.protobuf.GeneratedMessageLite<
          Tag, Tag.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.Tag)
      TagOrBuilder {
    private Tag() {
      tag_ = "";
      data_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int TAG_FIELD_NUMBER = 1;
    private java.lang.String tag_;
    /**
     * <code>required string tag = 1;</code>
     * @return Whether the tag field is set.
     */
    @java.lang.Override
    public boolean hasTag() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required string tag = 1;</code>
     * @return The tag.
     */
    @java.lang.Override
    public java.lang.String getTag() {
      return tag_;
    }
    /**
     * <code>required string tag = 1;</code>
     * @return The bytes for tag.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTagBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(tag_);
    }
    /**
     * <code>required string tag = 1;</code>
     * @param value The tag to set.
     */
    private void setTag(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      tag_ = value;
    }
    /**
     * <code>required string tag = 1;</code>
     */
    private void clearTag() {
      bitField0_ = (bitField0_ & ~0x00000001);
      tag_ = getDefaultInstance().getTag();
    }
    /**
     * <code>required string tag = 1;</code>
     * @param value The bytes for tag to set.
     */
    private void setTagBytes(
        com.google.protobuf.ByteString value) {
      tag_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int DATA_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString data_;
    /**
     * <code>required bytes data = 2;</code>
     * @return Whether the data field is set.
     */
    @java.lang.Override
    public boolean hasData() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>required bytes data = 2;</code>
     * @return The data.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getData() {
      return data_;
    }
    /**
     * <code>required bytes data = 2;</code>
     * @param value The data to set.
     */
    private void setData(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      data_ = value;
    }
    /**
     * <code>required bytes data = 2;</code>
     */
    private void clearData() {
      bitField0_ = (bitField0_ & ~0x00000002);
      data_ = getDefaultInstance().getData();
    }

    public static org.bitcoinj.wallet.Protos.Tag parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Tag parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.Tag prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     **
     * A simple key-&gt;value mapping that has no interpreted content at all. A bit like the extensions mechanism except
     * an extension is keyed by the ID of a piece of code that's loaded with the given data, and has the concept of
     * being mandatory if that code isn't found. Whereas this is just a blind key/value store.
     * </pre>
     *
     * Protobuf type {@code wallet.Tag}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.Tag, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.Tag)
        org.bitcoinj.wallet.Protos.TagOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.Tag.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required string tag = 1;</code>
       * @return Whether the tag field is set.
       */
      @java.lang.Override
      public boolean hasTag() {
        return instance.hasTag();
      }
      /**
       * <code>required string tag = 1;</code>
       * @return The tag.
       */
      @java.lang.Override
      public java.lang.String getTag() {
        return instance.getTag();
      }
      /**
       * <code>required string tag = 1;</code>
       * @return The bytes for tag.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTagBytes() {
        return instance.getTagBytes();
      }
      /**
       * <code>required string tag = 1;</code>
       * @param value The tag to set.
       * @return This builder for chaining.
       */
      public Builder setTag(
          java.lang.String value) {
        copyOnWrite();
        instance.setTag(value);
        return this;
      }
      /**
       * <code>required string tag = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTag() {
        copyOnWrite();
        instance.clearTag();
        return this;
      }
      /**
       * <code>required string tag = 1;</code>
       * @param value The bytes for tag to set.
       * @return This builder for chaining.
       */
      public Builder setTagBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTagBytes(value);
        return this;
      }

      /**
       * <code>required bytes data = 2;</code>
       * @return Whether the data field is set.
       */
      @java.lang.Override
      public boolean hasData() {
        return instance.hasData();
      }
      /**
       * <code>required bytes data = 2;</code>
       * @return The data.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getData() {
        return instance.getData();
      }
      /**
       * <code>required bytes data = 2;</code>
       * @param value The data to set.
       * @return This builder for chaining.
       */
      public Builder setData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setData(value);
        return this;
      }
      /**
       * <code>required bytes data = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearData() {
        copyOnWrite();
        instance.clearData();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.Tag)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.Tag();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "tag_",
              "data_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0002\u0001\u1508\u0000\u0002" +
                "\u150a\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.Tag> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.Tag.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.Tag>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.Tag)
    private static final org.bitcoinj.wallet.Protos.Tag DEFAULT_INSTANCE;
    static {
      Tag defaultInstance = new Tag();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Tag.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.Tag getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Tag> PARSER;

    public static com.google.protobuf.Parser<Tag> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface WalletOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.Wallet)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * the network used by this wallet
     * </pre>
     *
     * <code>required string network_identifier = 1;</code>
     * @return Whether the networkIdentifier field is set.
     */
    boolean hasNetworkIdentifier();
    /**
     * <pre>
     * the network used by this wallet
     * </pre>
     *
     * <code>required string network_identifier = 1;</code>
     * @return The networkIdentifier.
     */
    java.lang.String getNetworkIdentifier();
    /**
     * <pre>
     * the network used by this wallet
     * </pre>
     *
     * <code>required string network_identifier = 1;</code>
     * @return The bytes for networkIdentifier.
     */
    com.google.protobuf.ByteString
        getNetworkIdentifierBytes();

    /**
     * <pre>
     * The SHA256 hash of the head of the best chain seen by this wallet.
     * </pre>
     *
     * <code>optional bytes last_seen_block_hash = 2;</code>
     * @return Whether the lastSeenBlockHash field is set.
     */
    boolean hasLastSeenBlockHash();
    /**
     * <pre>
     * The SHA256 hash of the head of the best chain seen by this wallet.
     * </pre>
     *
     * <code>optional bytes last_seen_block_hash = 2;</code>
     * @return The lastSeenBlockHash.
     */
    com.google.protobuf.ByteString getLastSeenBlockHash();

    /**
     * <pre>
     * The height in the chain of the last seen block.
     * </pre>
     *
     * <code>optional uint32 last_seen_block_height = 12;</code>
     * @return Whether the lastSeenBlockHeight field is set.
     */
    boolean hasLastSeenBlockHeight();
    /**
     * <pre>
     * The height in the chain of the last seen block.
     * </pre>
     *
     * <code>optional uint32 last_seen_block_height = 12;</code>
     * @return The lastSeenBlockHeight.
     */
    int getLastSeenBlockHeight();

    /**
     * <code>optional int64 last_seen_block_time_secs = 14;</code>
     * @return Whether the lastSeenBlockTimeSecs field is set.
     */
    boolean hasLastSeenBlockTimeSecs();
    /**
     * <code>optional int64 last_seen_block_time_secs = 14;</code>
     * @return The lastSeenBlockTimeSecs.
     */
    long getLastSeenBlockTimeSecs();

    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    java.util.List<org.bitcoinj.wallet.Protos.Key> 
        getKeyList();
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    org.bitcoinj.wallet.Protos.Key getKey(int index);
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    int getKeyCount();

    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    java.util.List<org.bitcoinj.wallet.Protos.Transaction> 
        getTransactionList();
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    org.bitcoinj.wallet.Protos.Transaction getTransaction(int index);
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    int getTransactionCount();

    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    java.util.List<org.bitcoinj.wallet.Protos.Script> 
        getWatchedScriptList();
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    org.bitcoinj.wallet.Protos.Script getWatchedScript(int index);
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    int getWatchedScriptCount();

    /**
     * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
     * @return Whether the encryptionType field is set.
     */
    boolean hasEncryptionType();
    /**
     * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
     * @return The encryptionType.
     */
    org.bitcoinj.wallet.Protos.Wallet.EncryptionType getEncryptionType();

    /**
     * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
     * @return Whether the encryptionParameters field is set.
     */
    boolean hasEncryptionParameters();
    /**
     * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
     * @return The encryptionParameters.
     */
    org.bitcoinj.wallet.Protos.ScryptParameters getEncryptionParameters();

    /**
     * <pre>
     * The version number of the wallet - used to detect wallets that were produced in the future
     * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
     * A version that's higher than the default is considered from the future.
     * </pre>
     *
     * <code>optional int32 version = 7 [default = 1];</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <pre>
     * The version number of the wallet - used to detect wallets that were produced in the future
     * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
     * A version that's higher than the default is considered from the future.
     * </pre>
     *
     * <code>optional int32 version = 7 [default = 1];</code>
     * @return The version.
     */
    int getVersion();

    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    java.util.List<org.bitcoinj.wallet.Protos.Extension> 
        getExtensionList();
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    org.bitcoinj.wallet.Protos.Extension getExtension(int index);
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    int getExtensionCount();

    /**
     * <pre>
     * A UTF8 encoded text description of the wallet that is intended for end user provided text.
     * </pre>
     *
     * <code>optional string description = 11;</code>
     * @return Whether the description field is set.
     */
    boolean hasDescription();
    /**
     * <pre>
     * A UTF8 encoded text description of the wallet that is intended for end user provided text.
     * </pre>
     *
     * <code>optional string description = 11;</code>
     * @return The description.
     */
    java.lang.String getDescription();
    /**
     * <pre>
     * A UTF8 encoded text description of the wallet that is intended for end user provided text.
     * </pre>
     *
     * <code>optional string description = 11;</code>
     * @return The bytes for description.
     */
    com.google.protobuf.ByteString
        getDescriptionBytes();

    /**
     * <pre>
     * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
     * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
     * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
     * </pre>
     *
     * <code>optional uint64 key_rotation_time = 13;</code>
     * @return Whether the keyRotationTime field is set.
     */
    boolean hasKeyRotationTime();
    /**
     * <pre>
     * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
     * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
     * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
     * </pre>
     *
     * <code>optional uint64 key_rotation_time = 13;</code>
     * @return The keyRotationTime.
     */
    long getKeyRotationTime();

    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    java.util.List<org.bitcoinj.wallet.Protos.Tag> 
        getTagsList();
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    org.bitcoinj.wallet.Protos.Tag getTags(int index);
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    int getTagsCount();
  }
  /**
   * <pre>
   ** A bitcoin wallet 
   * </pre>
   *
   * Protobuf type {@code wallet.Wallet}
   */
  public  static final class Wallet extends
      com.google.protobuf.GeneratedMessageLite<
          Wallet, Wallet.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.Wallet)
      WalletOrBuilder {
    private Wallet() {
      networkIdentifier_ = "";
      lastSeenBlockHash_ = com.google.protobuf.ByteString.EMPTY;
      key_ = emptyProtobufList();
      transaction_ = emptyProtobufList();
      watchedScript_ = emptyProtobufList();
      encryptionType_ = 1;
      version_ = 1;
      extension_ = emptyProtobufList();
      description_ = "";
      tags_ = emptyProtobufList();
    }
    /**
     * <pre>
     **
     * The encryption type of the wallet.
     * The encryption type is UNENCRYPTED for wallets where the wallet does not support encryption - wallets prior to
     * encryption support are grandfathered in as this wallet type.
     * When a wallet is ENCRYPTED_SCRYPT_AES the keys are either encrypted with the wallet password or are unencrypted.
     * </pre>
     *
     * Protobuf enum {@code wallet.Wallet.EncryptionType}
     */
    public enum EncryptionType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * All keys in the wallet are unencrypted
       * </pre>
       *
       * <code>UNENCRYPTED = 1;</code>
       */
      UNENCRYPTED(1),
      /**
       * <pre>
       * All keys are encrypted with a passphrase based KDF of scrypt and AES encryption
       * </pre>
       *
       * <code>ENCRYPTED_SCRYPT_AES = 2;</code>
       */
      ENCRYPTED_SCRYPT_AES(2),
      ;

      /**
       * <pre>
       * All keys in the wallet are unencrypted
       * </pre>
       *
       * <code>UNENCRYPTED = 1;</code>
       */
      public static final int UNENCRYPTED_VALUE = 1;
      /**
       * <pre>
       * All keys are encrypted with a passphrase based KDF of scrypt and AES encryption
       * </pre>
       *
       * <code>ENCRYPTED_SCRYPT_AES = 2;</code>
       */
      public static final int ENCRYPTED_SCRYPT_AES_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static EncryptionType valueOf(int value) {
        return forNumber(value);
      }

      public static EncryptionType forNumber(int value) {
        switch (value) {
          case 1: return UNENCRYPTED;
          case 2: return ENCRYPTED_SCRYPT_AES;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<EncryptionType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          EncryptionType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<EncryptionType>() {
              @java.lang.Override
              public EncryptionType findValueByNumber(int number) {
                return EncryptionType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return EncryptionTypeVerifier.INSTANCE;
      }

      private static final class EncryptionTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new EncryptionTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return EncryptionType.forNumber(number) != null;
              }
            };

      private final int value;

      private EncryptionType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:wallet.Wallet.EncryptionType)
    }

    private int bitField0_;
    public static final int NETWORK_IDENTIFIER_FIELD_NUMBER = 1;
    private java.lang.String networkIdentifier_;
    /**
     * <pre>
     * the network used by this wallet
     * </pre>
     *
     * <code>required string network_identifier = 1;</code>
     * @return Whether the networkIdentifier field is set.
     */
    @java.lang.Override
    public boolean hasNetworkIdentifier() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * the network used by this wallet
     * </pre>
     *
     * <code>required string network_identifier = 1;</code>
     * @return The networkIdentifier.
     */
    @java.lang.Override
    public java.lang.String getNetworkIdentifier() {
      return networkIdentifier_;
    }
    /**
     * <pre>
     * the network used by this wallet
     * </pre>
     *
     * <code>required string network_identifier = 1;</code>
     * @return The bytes for networkIdentifier.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNetworkIdentifierBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(networkIdentifier_);
    }
    /**
     * <pre>
     * the network used by this wallet
     * </pre>
     *
     * <code>required string network_identifier = 1;</code>
     * @param value The networkIdentifier to set.
     */
    private void setNetworkIdentifier(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      networkIdentifier_ = value;
    }
    /**
     * <pre>
     * the network used by this wallet
     * </pre>
     *
     * <code>required string network_identifier = 1;</code>
     */
    private void clearNetworkIdentifier() {
      bitField0_ = (bitField0_ & ~0x00000001);
      networkIdentifier_ = getDefaultInstance().getNetworkIdentifier();
    }
    /**
     * <pre>
     * the network used by this wallet
     * </pre>
     *
     * <code>required string network_identifier = 1;</code>
     * @param value The bytes for networkIdentifier to set.
     */
    private void setNetworkIdentifierBytes(
        com.google.protobuf.ByteString value) {
      networkIdentifier_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int LAST_SEEN_BLOCK_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString lastSeenBlockHash_;
    /**
     * <pre>
     * The SHA256 hash of the head of the best chain seen by this wallet.
     * </pre>
     *
     * <code>optional bytes last_seen_block_hash = 2;</code>
     * @return Whether the lastSeenBlockHash field is set.
     */
    @java.lang.Override
    public boolean hasLastSeenBlockHash() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The SHA256 hash of the head of the best chain seen by this wallet.
     * </pre>
     *
     * <code>optional bytes last_seen_block_hash = 2;</code>
     * @return The lastSeenBlockHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLastSeenBlockHash() {
      return lastSeenBlockHash_;
    }
    /**
     * <pre>
     * The SHA256 hash of the head of the best chain seen by this wallet.
     * </pre>
     *
     * <code>optional bytes last_seen_block_hash = 2;</code>
     * @param value The lastSeenBlockHash to set.
     */
    private void setLastSeenBlockHash(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      lastSeenBlockHash_ = value;
    }
    /**
     * <pre>
     * The SHA256 hash of the head of the best chain seen by this wallet.
     * </pre>
     *
     * <code>optional bytes last_seen_block_hash = 2;</code>
     */
    private void clearLastSeenBlockHash() {
      bitField0_ = (bitField0_ & ~0x00000002);
      lastSeenBlockHash_ = getDefaultInstance().getLastSeenBlockHash();
    }

    public static final int LAST_SEEN_BLOCK_HEIGHT_FIELD_NUMBER = 12;
    private int lastSeenBlockHeight_;
    /**
     * <pre>
     * The height in the chain of the last seen block.
     * </pre>
     *
     * <code>optional uint32 last_seen_block_height = 12;</code>
     * @return Whether the lastSeenBlockHeight field is set.
     */
    @java.lang.Override
    public boolean hasLastSeenBlockHeight() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The height in the chain of the last seen block.
     * </pre>
     *
     * <code>optional uint32 last_seen_block_height = 12;</code>
     * @return The lastSeenBlockHeight.
     */
    @java.lang.Override
    public int getLastSeenBlockHeight() {
      return lastSeenBlockHeight_;
    }
    /**
     * <pre>
     * The height in the chain of the last seen block.
     * </pre>
     *
     * <code>optional uint32 last_seen_block_height = 12;</code>
     * @param value The lastSeenBlockHeight to set.
     */
    private void setLastSeenBlockHeight(int value) {
      bitField0_ |= 0x00000004;
      lastSeenBlockHeight_ = value;
    }
    /**
     * <pre>
     * The height in the chain of the last seen block.
     * </pre>
     *
     * <code>optional uint32 last_seen_block_height = 12;</code>
     */
    private void clearLastSeenBlockHeight() {
      bitField0_ = (bitField0_ & ~0x00000004);
      lastSeenBlockHeight_ = 0;
    }

    public static final int LAST_SEEN_BLOCK_TIME_SECS_FIELD_NUMBER = 14;
    private long lastSeenBlockTimeSecs_;
    /**
     * <code>optional int64 last_seen_block_time_secs = 14;</code>
     * @return Whether the lastSeenBlockTimeSecs field is set.
     */
    @java.lang.Override
    public boolean hasLastSeenBlockTimeSecs() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional int64 last_seen_block_time_secs = 14;</code>
     * @return The lastSeenBlockTimeSecs.
     */
    @java.lang.Override
    public long getLastSeenBlockTimeSecs() {
      return lastSeenBlockTimeSecs_;
    }
    /**
     * <code>optional int64 last_seen_block_time_secs = 14;</code>
     * @param value The lastSeenBlockTimeSecs to set.
     */
    private void setLastSeenBlockTimeSecs(long value) {
      bitField0_ |= 0x00000008;
      lastSeenBlockTimeSecs_ = value;
    }
    /**
     * <code>optional int64 last_seen_block_time_secs = 14;</code>
     */
    private void clearLastSeenBlockTimeSecs() {
      bitField0_ = (bitField0_ & ~0x00000008);
      lastSeenBlockTimeSecs_ = 0L;
    }

    public static final int KEY_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Key> key_;
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    @java.lang.Override
    public java.util.List<org.bitcoinj.wallet.Protos.Key> getKeyList() {
      return key_;
    }
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    public java.util.List<? extends org.bitcoinj.wallet.Protos.KeyOrBuilder> 
        getKeyOrBuilderList() {
      return key_;
    }
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    @java.lang.Override
    public int getKeyCount() {
      return key_.size();
    }
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Key getKey(int index) {
      return key_.get(index);
    }
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    public org.bitcoinj.wallet.Protos.KeyOrBuilder getKeyOrBuilder(
        int index) {
      return key_.get(index);
    }
    private void ensureKeyIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Key> tmp = key_;
      if (!tmp.isModifiable()) {
        key_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    private void setKey(
        int index, org.bitcoinj.wallet.Protos.Key value) {
      value.getClass();
  ensureKeyIsMutable();
      key_.set(index, value);
    }
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    private void addKey(org.bitcoinj.wallet.Protos.Key value) {
      value.getClass();
  ensureKeyIsMutable();
      key_.add(value);
    }
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    private void addKey(
        int index, org.bitcoinj.wallet.Protos.Key value) {
      value.getClass();
  ensureKeyIsMutable();
      key_.add(index, value);
    }
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    private void addAllKey(
        java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Key> values) {
      ensureKeyIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, key_);
    }
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    private void clearKey() {
      key_ = emptyProtobufList();
    }
    /**
     * <code>repeated .wallet.Key key = 3;</code>
     */
    private void removeKey(int index) {
      ensureKeyIsMutable();
      key_.remove(index);
    }

    public static final int TRANSACTION_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Transaction> transaction_;
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    @java.lang.Override
    public java.util.List<org.bitcoinj.wallet.Protos.Transaction> getTransactionList() {
      return transaction_;
    }
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    public java.util.List<? extends org.bitcoinj.wallet.Protos.TransactionOrBuilder> 
        getTransactionOrBuilderList() {
      return transaction_;
    }
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    @java.lang.Override
    public int getTransactionCount() {
      return transaction_.size();
    }
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Transaction getTransaction(int index) {
      return transaction_.get(index);
    }
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    public org.bitcoinj.wallet.Protos.TransactionOrBuilder getTransactionOrBuilder(
        int index) {
      return transaction_.get(index);
    }
    private void ensureTransactionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Transaction> tmp = transaction_;
      if (!tmp.isModifiable()) {
        transaction_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    private void setTransaction(
        int index, org.bitcoinj.wallet.Protos.Transaction value) {
      value.getClass();
  ensureTransactionIsMutable();
      transaction_.set(index, value);
    }
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    private void addTransaction(org.bitcoinj.wallet.Protos.Transaction value) {
      value.getClass();
  ensureTransactionIsMutable();
      transaction_.add(value);
    }
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    private void addTransaction(
        int index, org.bitcoinj.wallet.Protos.Transaction value) {
      value.getClass();
  ensureTransactionIsMutable();
      transaction_.add(index, value);
    }
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    private void addAllTransaction(
        java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Transaction> values) {
      ensureTransactionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, transaction_);
    }
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    private void clearTransaction() {
      transaction_ = emptyProtobufList();
    }
    /**
     * <code>repeated .wallet.Transaction transaction = 4;</code>
     */
    private void removeTransaction(int index) {
      ensureTransactionIsMutable();
      transaction_.remove(index);
    }

    public static final int WATCHED_SCRIPT_FIELD_NUMBER = 15;
    private com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Script> watchedScript_;
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    @java.lang.Override
    public java.util.List<org.bitcoinj.wallet.Protos.Script> getWatchedScriptList() {
      return watchedScript_;
    }
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    public java.util.List<? extends org.bitcoinj.wallet.Protos.ScriptOrBuilder> 
        getWatchedScriptOrBuilderList() {
      return watchedScript_;
    }
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    @java.lang.Override
    public int getWatchedScriptCount() {
      return watchedScript_.size();
    }
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Script getWatchedScript(int index) {
      return watchedScript_.get(index);
    }
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    public org.bitcoinj.wallet.Protos.ScriptOrBuilder getWatchedScriptOrBuilder(
        int index) {
      return watchedScript_.get(index);
    }
    private void ensureWatchedScriptIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Script> tmp = watchedScript_;
      if (!tmp.isModifiable()) {
        watchedScript_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    private void setWatchedScript(
        int index, org.bitcoinj.wallet.Protos.Script value) {
      value.getClass();
  ensureWatchedScriptIsMutable();
      watchedScript_.set(index, value);
    }
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    private void addWatchedScript(org.bitcoinj.wallet.Protos.Script value) {
      value.getClass();
  ensureWatchedScriptIsMutable();
      watchedScript_.add(value);
    }
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    private void addWatchedScript(
        int index, org.bitcoinj.wallet.Protos.Script value) {
      value.getClass();
  ensureWatchedScriptIsMutable();
      watchedScript_.add(index, value);
    }
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    private void addAllWatchedScript(
        java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Script> values) {
      ensureWatchedScriptIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, watchedScript_);
    }
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    private void clearWatchedScript() {
      watchedScript_ = emptyProtobufList();
    }
    /**
     * <code>repeated .wallet.Script watched_script = 15;</code>
     */
    private void removeWatchedScript(int index) {
      ensureWatchedScriptIsMutable();
      watchedScript_.remove(index);
    }

    public static final int ENCRYPTION_TYPE_FIELD_NUMBER = 5;
    private int encryptionType_;
    /**
     * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
     * @return Whether the encryptionType field is set.
     */
    @java.lang.Override
    public boolean hasEncryptionType() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
     * @return The encryptionType.
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Wallet.EncryptionType getEncryptionType() {
      org.bitcoinj.wallet.Protos.Wallet.EncryptionType result = org.bitcoinj.wallet.Protos.Wallet.EncryptionType.forNumber(encryptionType_);
      return result == null ? org.bitcoinj.wallet.Protos.Wallet.EncryptionType.UNENCRYPTED : result;
    }
    /**
     * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
     * @param value The encryptionType to set.
     */
    private void setEncryptionType(org.bitcoinj.wallet.Protos.Wallet.EncryptionType value) {
      encryptionType_ = value.getNumber();
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
     */
    private void clearEncryptionType() {
      bitField0_ = (bitField0_ & ~0x00000010);
      encryptionType_ = 1;
    }

    public static final int ENCRYPTION_PARAMETERS_FIELD_NUMBER = 6;
    private org.bitcoinj.wallet.Protos.ScryptParameters encryptionParameters_;
    /**
     * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
     */
    @java.lang.Override
    public boolean hasEncryptionParameters() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.ScryptParameters getEncryptionParameters() {
      return encryptionParameters_ == null ? org.bitcoinj.wallet.Protos.ScryptParameters.getDefaultInstance() : encryptionParameters_;
    }
    /**
     * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
     */
    private void setEncryptionParameters(org.bitcoinj.wallet.Protos.ScryptParameters value) {
      value.getClass();
  encryptionParameters_ = value;
      bitField0_ |= 0x00000020;
      }
    /**
     * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeEncryptionParameters(org.bitcoinj.wallet.Protos.ScryptParameters value) {
      value.getClass();
  if (encryptionParameters_ != null &&
          encryptionParameters_ != org.bitcoinj.wallet.Protos.ScryptParameters.getDefaultInstance()) {
        encryptionParameters_ =
          org.bitcoinj.wallet.Protos.ScryptParameters.newBuilder(encryptionParameters_).mergeFrom(value).buildPartial();
      } else {
        encryptionParameters_ = value;
      }
      bitField0_ |= 0x00000020;
    }
    /**
     * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
     */
    private void clearEncryptionParameters() {  encryptionParameters_ = null;
      bitField0_ = (bitField0_ & ~0x00000020);
    }

    public static final int VERSION_FIELD_NUMBER = 7;
    private int version_;
    /**
     * <pre>
     * The version number of the wallet - used to detect wallets that were produced in the future
     * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
     * A version that's higher than the default is considered from the future.
     * </pre>
     *
     * <code>optional int32 version = 7 [default = 1];</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * The version number of the wallet - used to detect wallets that were produced in the future
     * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
     * A version that's higher than the default is considered from the future.
     * </pre>
     *
     * <code>optional int32 version = 7 [default = 1];</code>
     * @return The version.
     */
    @java.lang.Override
    public int getVersion() {
      return version_;
    }
    /**
     * <pre>
     * The version number of the wallet - used to detect wallets that were produced in the future
     * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
     * A version that's higher than the default is considered from the future.
     * </pre>
     *
     * <code>optional int32 version = 7 [default = 1];</code>
     * @param value The version to set.
     */
    private void setVersion(int value) {
      bitField0_ |= 0x00000040;
      version_ = value;
    }
    /**
     * <pre>
     * The version number of the wallet - used to detect wallets that were produced in the future
     * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
     * A version that's higher than the default is considered from the future.
     * </pre>
     *
     * <code>optional int32 version = 7 [default = 1];</code>
     */
    private void clearVersion() {
      bitField0_ = (bitField0_ & ~0x00000040);
      version_ = 1;
    }

    public static final int EXTENSION_FIELD_NUMBER = 10;
    private com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Extension> extension_;
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    @java.lang.Override
    public java.util.List<org.bitcoinj.wallet.Protos.Extension> getExtensionList() {
      return extension_;
    }
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    public java.util.List<? extends org.bitcoinj.wallet.Protos.ExtensionOrBuilder> 
        getExtensionOrBuilderList() {
      return extension_;
    }
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    @java.lang.Override
    public int getExtensionCount() {
      return extension_.size();
    }
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Extension getExtension(int index) {
      return extension_.get(index);
    }
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    public org.bitcoinj.wallet.Protos.ExtensionOrBuilder getExtensionOrBuilder(
        int index) {
      return extension_.get(index);
    }
    private void ensureExtensionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Extension> tmp = extension_;
      if (!tmp.isModifiable()) {
        extension_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    private void setExtension(
        int index, org.bitcoinj.wallet.Protos.Extension value) {
      value.getClass();
  ensureExtensionIsMutable();
      extension_.set(index, value);
    }
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    private void addExtension(org.bitcoinj.wallet.Protos.Extension value) {
      value.getClass();
  ensureExtensionIsMutable();
      extension_.add(value);
    }
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    private void addExtension(
        int index, org.bitcoinj.wallet.Protos.Extension value) {
      value.getClass();
  ensureExtensionIsMutable();
      extension_.add(index, value);
    }
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    private void addAllExtension(
        java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Extension> values) {
      ensureExtensionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, extension_);
    }
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    private void clearExtension() {
      extension_ = emptyProtobufList();
    }
    /**
     * <code>repeated .wallet.Extension extension = 10;</code>
     */
    private void removeExtension(int index) {
      ensureExtensionIsMutable();
      extension_.remove(index);
    }

    public static final int DESCRIPTION_FIELD_NUMBER = 11;
    private java.lang.String description_;
    /**
     * <pre>
     * A UTF8 encoded text description of the wallet that is intended for end user provided text.
     * </pre>
     *
     * <code>optional string description = 11;</code>
     * @return Whether the description field is set.
     */
    @java.lang.Override
    public boolean hasDescription() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * A UTF8 encoded text description of the wallet that is intended for end user provided text.
     * </pre>
     *
     * <code>optional string description = 11;</code>
     * @return The description.
     */
    @java.lang.Override
    public java.lang.String getDescription() {
      return description_;
    }
    /**
     * <pre>
     * A UTF8 encoded text description of the wallet that is intended for end user provided text.
     * </pre>
     *
     * <code>optional string description = 11;</code>
     * @return The bytes for description.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDescriptionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(description_);
    }
    /**
     * <pre>
     * A UTF8 encoded text description of the wallet that is intended for end user provided text.
     * </pre>
     *
     * <code>optional string description = 11;</code>
     * @param value The description to set.
     */
    private void setDescription(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000080;
      description_ = value;
    }
    /**
     * <pre>
     * A UTF8 encoded text description of the wallet that is intended for end user provided text.
     * </pre>
     *
     * <code>optional string description = 11;</code>
     */
    private void clearDescription() {
      bitField0_ = (bitField0_ & ~0x00000080);
      description_ = getDefaultInstance().getDescription();
    }
    /**
     * <pre>
     * A UTF8 encoded text description of the wallet that is intended for end user provided text.
     * </pre>
     *
     * <code>optional string description = 11;</code>
     * @param value The bytes for description to set.
     */
    private void setDescriptionBytes(
        com.google.protobuf.ByteString value) {
      description_ = value.toStringUtf8();
      bitField0_ |= 0x00000080;
    }

    public static final int KEY_ROTATION_TIME_FIELD_NUMBER = 13;
    private long keyRotationTime_;
    /**
     * <pre>
     * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
     * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
     * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
     * </pre>
     *
     * <code>optional uint64 key_rotation_time = 13;</code>
     * @return Whether the keyRotationTime field is set.
     */
    @java.lang.Override
    public boolean hasKeyRotationTime() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
     * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
     * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
     * </pre>
     *
     * <code>optional uint64 key_rotation_time = 13;</code>
     * @return The keyRotationTime.
     */
    @java.lang.Override
    public long getKeyRotationTime() {
      return keyRotationTime_;
    }
    /**
     * <pre>
     * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
     * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
     * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
     * </pre>
     *
     * <code>optional uint64 key_rotation_time = 13;</code>
     * @param value The keyRotationTime to set.
     */
    private void setKeyRotationTime(long value) {
      bitField0_ |= 0x00000100;
      keyRotationTime_ = value;
    }
    /**
     * <pre>
     * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
     * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
     * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
     * </pre>
     *
     * <code>optional uint64 key_rotation_time = 13;</code>
     */
    private void clearKeyRotationTime() {
      bitField0_ = (bitField0_ & ~0x00000100);
      keyRotationTime_ = 0L;
    }

    public static final int TAGS_FIELD_NUMBER = 16;
    private com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Tag> tags_;
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    @java.lang.Override
    public java.util.List<org.bitcoinj.wallet.Protos.Tag> getTagsList() {
      return tags_;
    }
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    public java.util.List<? extends org.bitcoinj.wallet.Protos.TagOrBuilder> 
        getTagsOrBuilderList() {
      return tags_;
    }
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    @java.lang.Override
    public int getTagsCount() {
      return tags_.size();
    }
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    @java.lang.Override
    public org.bitcoinj.wallet.Protos.Tag getTags(int index) {
      return tags_.get(index);
    }
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    public org.bitcoinj.wallet.Protos.TagOrBuilder getTagsOrBuilder(
        int index) {
      return tags_.get(index);
    }
    private void ensureTagsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.bitcoinj.wallet.Protos.Tag> tmp = tags_;
      if (!tmp.isModifiable()) {
        tags_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    private void setTags(
        int index, org.bitcoinj.wallet.Protos.Tag value) {
      value.getClass();
  ensureTagsIsMutable();
      tags_.set(index, value);
    }
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    private void addTags(org.bitcoinj.wallet.Protos.Tag value) {
      value.getClass();
  ensureTagsIsMutable();
      tags_.add(value);
    }
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    private void addTags(
        int index, org.bitcoinj.wallet.Protos.Tag value) {
      value.getClass();
  ensureTagsIsMutable();
      tags_.add(index, value);
    }
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    private void addAllTags(
        java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Tag> values) {
      ensureTagsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, tags_);
    }
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    private void clearTags() {
      tags_ = emptyProtobufList();
    }
    /**
     * <code>repeated .wallet.Tag tags = 16;</code>
     */
    private void removeTags(int index) {
      ensureTagsIsMutable();
      tags_.remove(index);
    }

    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.Wallet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.Wallet prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     ** A bitcoin wallet 
     * </pre>
     *
     * Protobuf type {@code wallet.Wallet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.Wallet, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.Wallet)
        org.bitcoinj.wallet.Protos.WalletOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.Wallet.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * the network used by this wallet
       * </pre>
       *
       * <code>required string network_identifier = 1;</code>
       * @return Whether the networkIdentifier field is set.
       */
      @java.lang.Override
      public boolean hasNetworkIdentifier() {
        return instance.hasNetworkIdentifier();
      }
      /**
       * <pre>
       * the network used by this wallet
       * </pre>
       *
       * <code>required string network_identifier = 1;</code>
       * @return The networkIdentifier.
       */
      @java.lang.Override
      public java.lang.String getNetworkIdentifier() {
        return instance.getNetworkIdentifier();
      }
      /**
       * <pre>
       * the network used by this wallet
       * </pre>
       *
       * <code>required string network_identifier = 1;</code>
       * @return The bytes for networkIdentifier.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNetworkIdentifierBytes() {
        return instance.getNetworkIdentifierBytes();
      }
      /**
       * <pre>
       * the network used by this wallet
       * </pre>
       *
       * <code>required string network_identifier = 1;</code>
       * @param value The networkIdentifier to set.
       * @return This builder for chaining.
       */
      public Builder setNetworkIdentifier(
          java.lang.String value) {
        copyOnWrite();
        instance.setNetworkIdentifier(value);
        return this;
      }
      /**
       * <pre>
       * the network used by this wallet
       * </pre>
       *
       * <code>required string network_identifier = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNetworkIdentifier() {
        copyOnWrite();
        instance.clearNetworkIdentifier();
        return this;
      }
      /**
       * <pre>
       * the network used by this wallet
       * </pre>
       *
       * <code>required string network_identifier = 1;</code>
       * @param value The bytes for networkIdentifier to set.
       * @return This builder for chaining.
       */
      public Builder setNetworkIdentifierBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNetworkIdentifierBytes(value);
        return this;
      }

      /**
       * <pre>
       * The SHA256 hash of the head of the best chain seen by this wallet.
       * </pre>
       *
       * <code>optional bytes last_seen_block_hash = 2;</code>
       * @return Whether the lastSeenBlockHash field is set.
       */
      @java.lang.Override
      public boolean hasLastSeenBlockHash() {
        return instance.hasLastSeenBlockHash();
      }
      /**
       * <pre>
       * The SHA256 hash of the head of the best chain seen by this wallet.
       * </pre>
       *
       * <code>optional bytes last_seen_block_hash = 2;</code>
       * @return The lastSeenBlockHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLastSeenBlockHash() {
        return instance.getLastSeenBlockHash();
      }
      /**
       * <pre>
       * The SHA256 hash of the head of the best chain seen by this wallet.
       * </pre>
       *
       * <code>optional bytes last_seen_block_hash = 2;</code>
       * @param value The lastSeenBlockHash to set.
       * @return This builder for chaining.
       */
      public Builder setLastSeenBlockHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLastSeenBlockHash(value);
        return this;
      }
      /**
       * <pre>
       * The SHA256 hash of the head of the best chain seen by this wallet.
       * </pre>
       *
       * <code>optional bytes last_seen_block_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastSeenBlockHash() {
        copyOnWrite();
        instance.clearLastSeenBlockHash();
        return this;
      }

      /**
       * <pre>
       * The height in the chain of the last seen block.
       * </pre>
       *
       * <code>optional uint32 last_seen_block_height = 12;</code>
       * @return Whether the lastSeenBlockHeight field is set.
       */
      @java.lang.Override
      public boolean hasLastSeenBlockHeight() {
        return instance.hasLastSeenBlockHeight();
      }
      /**
       * <pre>
       * The height in the chain of the last seen block.
       * </pre>
       *
       * <code>optional uint32 last_seen_block_height = 12;</code>
       * @return The lastSeenBlockHeight.
       */
      @java.lang.Override
      public int getLastSeenBlockHeight() {
        return instance.getLastSeenBlockHeight();
      }
      /**
       * <pre>
       * The height in the chain of the last seen block.
       * </pre>
       *
       * <code>optional uint32 last_seen_block_height = 12;</code>
       * @param value The lastSeenBlockHeight to set.
       * @return This builder for chaining.
       */
      public Builder setLastSeenBlockHeight(int value) {
        copyOnWrite();
        instance.setLastSeenBlockHeight(value);
        return this;
      }
      /**
       * <pre>
       * The height in the chain of the last seen block.
       * </pre>
       *
       * <code>optional uint32 last_seen_block_height = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastSeenBlockHeight() {
        copyOnWrite();
        instance.clearLastSeenBlockHeight();
        return this;
      }

      /**
       * <code>optional int64 last_seen_block_time_secs = 14;</code>
       * @return Whether the lastSeenBlockTimeSecs field is set.
       */
      @java.lang.Override
      public boolean hasLastSeenBlockTimeSecs() {
        return instance.hasLastSeenBlockTimeSecs();
      }
      /**
       * <code>optional int64 last_seen_block_time_secs = 14;</code>
       * @return The lastSeenBlockTimeSecs.
       */
      @java.lang.Override
      public long getLastSeenBlockTimeSecs() {
        return instance.getLastSeenBlockTimeSecs();
      }
      /**
       * <code>optional int64 last_seen_block_time_secs = 14;</code>
       * @param value The lastSeenBlockTimeSecs to set.
       * @return This builder for chaining.
       */
      public Builder setLastSeenBlockTimeSecs(long value) {
        copyOnWrite();
        instance.setLastSeenBlockTimeSecs(value);
        return this;
      }
      /**
       * <code>optional int64 last_seen_block_time_secs = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastSeenBlockTimeSecs() {
        copyOnWrite();
        instance.clearLastSeenBlockTimeSecs();
        return this;
      }

      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      @java.lang.Override
      public java.util.List<org.bitcoinj.wallet.Protos.Key> getKeyList() {
        return java.util.Collections.unmodifiableList(
            instance.getKeyList());
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      @java.lang.Override
      public int getKeyCount() {
        return instance.getKeyCount();
      }/**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Key getKey(int index) {
        return instance.getKey(index);
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      public Builder setKey(
          int index, org.bitcoinj.wallet.Protos.Key value) {
        copyOnWrite();
        instance.setKey(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      public Builder setKey(
          int index, org.bitcoinj.wallet.Protos.Key.Builder builderForValue) {
        copyOnWrite();
        instance.setKey(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      public Builder addKey(org.bitcoinj.wallet.Protos.Key value) {
        copyOnWrite();
        instance.addKey(value);
        return this;
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      public Builder addKey(
          int index, org.bitcoinj.wallet.Protos.Key value) {
        copyOnWrite();
        instance.addKey(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      public Builder addKey(
          org.bitcoinj.wallet.Protos.Key.Builder builderForValue) {
        copyOnWrite();
        instance.addKey(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      public Builder addKey(
          int index, org.bitcoinj.wallet.Protos.Key.Builder builderForValue) {
        copyOnWrite();
        instance.addKey(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      public Builder addAllKey(
          java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Key> values) {
        copyOnWrite();
        instance.addAllKey(values);
        return this;
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      public Builder clearKey() {
        copyOnWrite();
        instance.clearKey();
        return this;
      }
      /**
       * <code>repeated .wallet.Key key = 3;</code>
       */
      public Builder removeKey(int index) {
        copyOnWrite();
        instance.removeKey(index);
        return this;
      }

      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      @java.lang.Override
      public java.util.List<org.bitcoinj.wallet.Protos.Transaction> getTransactionList() {
        return java.util.Collections.unmodifiableList(
            instance.getTransactionList());
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      @java.lang.Override
      public int getTransactionCount() {
        return instance.getTransactionCount();
      }/**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Transaction getTransaction(int index) {
        return instance.getTransaction(index);
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      public Builder setTransaction(
          int index, org.bitcoinj.wallet.Protos.Transaction value) {
        copyOnWrite();
        instance.setTransaction(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      public Builder setTransaction(
          int index, org.bitcoinj.wallet.Protos.Transaction.Builder builderForValue) {
        copyOnWrite();
        instance.setTransaction(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      public Builder addTransaction(org.bitcoinj.wallet.Protos.Transaction value) {
        copyOnWrite();
        instance.addTransaction(value);
        return this;
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      public Builder addTransaction(
          int index, org.bitcoinj.wallet.Protos.Transaction value) {
        copyOnWrite();
        instance.addTransaction(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      public Builder addTransaction(
          org.bitcoinj.wallet.Protos.Transaction.Builder builderForValue) {
        copyOnWrite();
        instance.addTransaction(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      public Builder addTransaction(
          int index, org.bitcoinj.wallet.Protos.Transaction.Builder builderForValue) {
        copyOnWrite();
        instance.addTransaction(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      public Builder addAllTransaction(
          java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Transaction> values) {
        copyOnWrite();
        instance.addAllTransaction(values);
        return this;
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      public Builder clearTransaction() {
        copyOnWrite();
        instance.clearTransaction();
        return this;
      }
      /**
       * <code>repeated .wallet.Transaction transaction = 4;</code>
       */
      public Builder removeTransaction(int index) {
        copyOnWrite();
        instance.removeTransaction(index);
        return this;
      }

      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      @java.lang.Override
      public java.util.List<org.bitcoinj.wallet.Protos.Script> getWatchedScriptList() {
        return java.util.Collections.unmodifiableList(
            instance.getWatchedScriptList());
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      @java.lang.Override
      public int getWatchedScriptCount() {
        return instance.getWatchedScriptCount();
      }/**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Script getWatchedScript(int index) {
        return instance.getWatchedScript(index);
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      public Builder setWatchedScript(
          int index, org.bitcoinj.wallet.Protos.Script value) {
        copyOnWrite();
        instance.setWatchedScript(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      public Builder setWatchedScript(
          int index, org.bitcoinj.wallet.Protos.Script.Builder builderForValue) {
        copyOnWrite();
        instance.setWatchedScript(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      public Builder addWatchedScript(org.bitcoinj.wallet.Protos.Script value) {
        copyOnWrite();
        instance.addWatchedScript(value);
        return this;
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      public Builder addWatchedScript(
          int index, org.bitcoinj.wallet.Protos.Script value) {
        copyOnWrite();
        instance.addWatchedScript(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      public Builder addWatchedScript(
          org.bitcoinj.wallet.Protos.Script.Builder builderForValue) {
        copyOnWrite();
        instance.addWatchedScript(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      public Builder addWatchedScript(
          int index, org.bitcoinj.wallet.Protos.Script.Builder builderForValue) {
        copyOnWrite();
        instance.addWatchedScript(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      public Builder addAllWatchedScript(
          java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Script> values) {
        copyOnWrite();
        instance.addAllWatchedScript(values);
        return this;
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      public Builder clearWatchedScript() {
        copyOnWrite();
        instance.clearWatchedScript();
        return this;
      }
      /**
       * <code>repeated .wallet.Script watched_script = 15;</code>
       */
      public Builder removeWatchedScript(int index) {
        copyOnWrite();
        instance.removeWatchedScript(index);
        return this;
      }

      /**
       * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
       * @return Whether the encryptionType field is set.
       */
      @java.lang.Override
      public boolean hasEncryptionType() {
        return instance.hasEncryptionType();
      }
      /**
       * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
       * @return The encryptionType.
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Wallet.EncryptionType getEncryptionType() {
        return instance.getEncryptionType();
      }
      /**
       * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
       * @param value The enum numeric value on the wire for encryptionType to set.
       * @return This builder for chaining.
       */
      public Builder setEncryptionType(org.bitcoinj.wallet.Protos.Wallet.EncryptionType value) {
        copyOnWrite();
        instance.setEncryptionType(value);
        return this;
      }
      /**
       * <code>optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];</code>
       * @return This builder for chaining.
       */
      public Builder clearEncryptionType() {
        copyOnWrite();
        instance.clearEncryptionType();
        return this;
      }

      /**
       * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
       */
      @java.lang.Override
      public boolean hasEncryptionParameters() {
        return instance.hasEncryptionParameters();
      }
      /**
       * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.ScryptParameters getEncryptionParameters() {
        return instance.getEncryptionParameters();
      }
      /**
       * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
       */
      public Builder setEncryptionParameters(org.bitcoinj.wallet.Protos.ScryptParameters value) {
        copyOnWrite();
        instance.setEncryptionParameters(value);
        return this;
        }
      /**
       * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
       */
      public Builder setEncryptionParameters(
          org.bitcoinj.wallet.Protos.ScryptParameters.Builder builderForValue) {
        copyOnWrite();
        instance.setEncryptionParameters(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
       */
      public Builder mergeEncryptionParameters(org.bitcoinj.wallet.Protos.ScryptParameters value) {
        copyOnWrite();
        instance.mergeEncryptionParameters(value);
        return this;
      }
      /**
       * <code>optional .wallet.ScryptParameters encryption_parameters = 6;</code>
       */
      public Builder clearEncryptionParameters() {  copyOnWrite();
        instance.clearEncryptionParameters();
        return this;
      }

      /**
       * <pre>
       * The version number of the wallet - used to detect wallets that were produced in the future
       * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
       * A version that's higher than the default is considered from the future.
       * </pre>
       *
       * <code>optional int32 version = 7 [default = 1];</code>
       * @return Whether the version field is set.
       */
      @java.lang.Override
      public boolean hasVersion() {
        return instance.hasVersion();
      }
      /**
       * <pre>
       * The version number of the wallet - used to detect wallets that were produced in the future
       * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
       * A version that's higher than the default is considered from the future.
       * </pre>
       *
       * <code>optional int32 version = 7 [default = 1];</code>
       * @return The version.
       */
      @java.lang.Override
      public int getVersion() {
        return instance.getVersion();
      }
      /**
       * <pre>
       * The version number of the wallet - used to detect wallets that were produced in the future
       * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
       * A version that's higher than the default is considered from the future.
       * </pre>
       *
       * <code>optional int32 version = 7 [default = 1];</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(int value) {
        copyOnWrite();
        instance.setVersion(value);
        return this;
      }
      /**
       * <pre>
       * The version number of the wallet - used to detect wallets that were produced in the future
       * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
       * A version that's higher than the default is considered from the future.
       * </pre>
       *
       * <code>optional int32 version = 7 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        copyOnWrite();
        instance.clearVersion();
        return this;
      }

      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      @java.lang.Override
      public java.util.List<org.bitcoinj.wallet.Protos.Extension> getExtensionList() {
        return java.util.Collections.unmodifiableList(
            instance.getExtensionList());
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      @java.lang.Override
      public int getExtensionCount() {
        return instance.getExtensionCount();
      }/**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Extension getExtension(int index) {
        return instance.getExtension(index);
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      public Builder setExtension(
          int index, org.bitcoinj.wallet.Protos.Extension value) {
        copyOnWrite();
        instance.setExtension(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      public Builder setExtension(
          int index, org.bitcoinj.wallet.Protos.Extension.Builder builderForValue) {
        copyOnWrite();
        instance.setExtension(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      public Builder addExtension(org.bitcoinj.wallet.Protos.Extension value) {
        copyOnWrite();
        instance.addExtension(value);
        return this;
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      public Builder addExtension(
          int index, org.bitcoinj.wallet.Protos.Extension value) {
        copyOnWrite();
        instance.addExtension(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      public Builder addExtension(
          org.bitcoinj.wallet.Protos.Extension.Builder builderForValue) {
        copyOnWrite();
        instance.addExtension(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      public Builder addExtension(
          int index, org.bitcoinj.wallet.Protos.Extension.Builder builderForValue) {
        copyOnWrite();
        instance.addExtension(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      public Builder addAllExtension(
          java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Extension> values) {
        copyOnWrite();
        instance.addAllExtension(values);
        return this;
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      public Builder clearExtension() {
        copyOnWrite();
        instance.clearExtension();
        return this;
      }
      /**
       * <code>repeated .wallet.Extension extension = 10;</code>
       */
      public Builder removeExtension(int index) {
        copyOnWrite();
        instance.removeExtension(index);
        return this;
      }

      /**
       * <pre>
       * A UTF8 encoded text description of the wallet that is intended for end user provided text.
       * </pre>
       *
       * <code>optional string description = 11;</code>
       * @return Whether the description field is set.
       */
      @java.lang.Override
      public boolean hasDescription() {
        return instance.hasDescription();
      }
      /**
       * <pre>
       * A UTF8 encoded text description of the wallet that is intended for end user provided text.
       * </pre>
       *
       * <code>optional string description = 11;</code>
       * @return The description.
       */
      @java.lang.Override
      public java.lang.String getDescription() {
        return instance.getDescription();
      }
      /**
       * <pre>
       * A UTF8 encoded text description of the wallet that is intended for end user provided text.
       * </pre>
       *
       * <code>optional string description = 11;</code>
       * @return The bytes for description.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDescriptionBytes() {
        return instance.getDescriptionBytes();
      }
      /**
       * <pre>
       * A UTF8 encoded text description of the wallet that is intended for end user provided text.
       * </pre>
       *
       * <code>optional string description = 11;</code>
       * @param value The description to set.
       * @return This builder for chaining.
       */
      public Builder setDescription(
          java.lang.String value) {
        copyOnWrite();
        instance.setDescription(value);
        return this;
      }
      /**
       * <pre>
       * A UTF8 encoded text description of the wallet that is intended for end user provided text.
       * </pre>
       *
       * <code>optional string description = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearDescription() {
        copyOnWrite();
        instance.clearDescription();
        return this;
      }
      /**
       * <pre>
       * A UTF8 encoded text description of the wallet that is intended for end user provided text.
       * </pre>
       *
       * <code>optional string description = 11;</code>
       * @param value The bytes for description to set.
       * @return This builder for chaining.
       */
      public Builder setDescriptionBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDescriptionBytes(value);
        return this;
      }

      /**
       * <pre>
       * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
       * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
       * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
       * </pre>
       *
       * <code>optional uint64 key_rotation_time = 13;</code>
       * @return Whether the keyRotationTime field is set.
       */
      @java.lang.Override
      public boolean hasKeyRotationTime() {
        return instance.hasKeyRotationTime();
      }
      /**
       * <pre>
       * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
       * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
       * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
       * </pre>
       *
       * <code>optional uint64 key_rotation_time = 13;</code>
       * @return The keyRotationTime.
       */
      @java.lang.Override
      public long getKeyRotationTime() {
        return instance.getKeyRotationTime();
      }
      /**
       * <pre>
       * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
       * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
       * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
       * </pre>
       *
       * <code>optional uint64 key_rotation_time = 13;</code>
       * @param value The keyRotationTime to set.
       * @return This builder for chaining.
       */
      public Builder setKeyRotationTime(long value) {
        copyOnWrite();
        instance.setKeyRotationTime(value);
        return this;
      }
      /**
       * <pre>
       * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
       * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
       * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
       * </pre>
       *
       * <code>optional uint64 key_rotation_time = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyRotationTime() {
        copyOnWrite();
        instance.clearKeyRotationTime();
        return this;
      }

      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      @java.lang.Override
      public java.util.List<org.bitcoinj.wallet.Protos.Tag> getTagsList() {
        return java.util.Collections.unmodifiableList(
            instance.getTagsList());
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      @java.lang.Override
      public int getTagsCount() {
        return instance.getTagsCount();
      }/**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      @java.lang.Override
      public org.bitcoinj.wallet.Protos.Tag getTags(int index) {
        return instance.getTags(index);
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      public Builder setTags(
          int index, org.bitcoinj.wallet.Protos.Tag value) {
        copyOnWrite();
        instance.setTags(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      public Builder setTags(
          int index, org.bitcoinj.wallet.Protos.Tag.Builder builderForValue) {
        copyOnWrite();
        instance.setTags(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      public Builder addTags(org.bitcoinj.wallet.Protos.Tag value) {
        copyOnWrite();
        instance.addTags(value);
        return this;
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      public Builder addTags(
          int index, org.bitcoinj.wallet.Protos.Tag value) {
        copyOnWrite();
        instance.addTags(index, value);
        return this;
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      public Builder addTags(
          org.bitcoinj.wallet.Protos.Tag.Builder builderForValue) {
        copyOnWrite();
        instance.addTags(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      public Builder addTags(
          int index, org.bitcoinj.wallet.Protos.Tag.Builder builderForValue) {
        copyOnWrite();
        instance.addTags(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      public Builder addAllTags(
          java.lang.Iterable<? extends org.bitcoinj.wallet.Protos.Tag> values) {
        copyOnWrite();
        instance.addAllTags(values);
        return this;
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      public Builder clearTags() {
        copyOnWrite();
        instance.clearTags();
        return this;
      }
      /**
       * <code>repeated .wallet.Tag tags = 16;</code>
       */
      public Builder removeTags(int index) {
        copyOnWrite();
        instance.removeTags(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.Wallet)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.Wallet();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "networkIdentifier_",
              "lastSeenBlockHash_",
              "key_",
              org.bitcoinj.wallet.Protos.Key.class,
              "transaction_",
              org.bitcoinj.wallet.Protos.Transaction.class,
              "encryptionType_",
              org.bitcoinj.wallet.Protos.Wallet.EncryptionType.internalGetVerifier(),
              "encryptionParameters_",
              "version_",
              "extension_",
              org.bitcoinj.wallet.Protos.Extension.class,
              "description_",
              "lastSeenBlockHeight_",
              "keyRotationTime_",
              "lastSeenBlockTimeSecs_",
              "watchedScript_",
              org.bitcoinj.wallet.Protos.Script.class,
              "tags_",
              org.bitcoinj.wallet.Protos.Tag.class,
            };
            java.lang.String info =
                "\u0001\u000e\u0000\u0001\u0001\u0010\u000e\u0000\u0005\u0007\u0001\u1508\u0000\u0002" +
                "\u100a\u0001\u0003\u041b\u0004\u041b\u0005\u100c\u0004\u0006\u1409\u0005\u0007\u1004" +
                "\u0006\n\u041b\u000b\u1008\u0007\f\u100b\u0002\r\u1003\b\u000e\u1002\u0003\u000f" +
                "\u041b\u0010\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.Wallet> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.Wallet.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.Wallet>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.Wallet)
    private static final org.bitcoinj.wallet.Protos.Wallet DEFAULT_INSTANCE;
    static {
      Wallet defaultInstance = new Wallet();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Wallet.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.Wallet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Wallet> PARSER;

    public static com.google.protobuf.Parser<Wallet> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ExchangeRateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:wallet.ExchangeRate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This much of satoshis (1E-8 fractions)
     * </pre>
     *
     * <code>required int64 coin_value = 1;</code>
     * @return Whether the coinValue field is set.
     */
    boolean hasCoinValue();
    /**
     * <pre>
     * This much of satoshis (1E-8 fractions)
     * </pre>
     *
     * <code>required int64 coin_value = 1;</code>
     * @return The coinValue.
     */
    long getCoinValue();

    /**
     * <pre>
     * is worth this much of fiat (1E-4 fractions).
     * </pre>
     *
     * <code>required int64 fiat_value = 2;</code>
     * @return Whether the fiatValue field is set.
     */
    boolean hasFiatValue();
    /**
     * <pre>
     * is worth this much of fiat (1E-4 fractions).
     * </pre>
     *
     * <code>required int64 fiat_value = 2;</code>
     * @return The fiatValue.
     */
    long getFiatValue();

    /**
     * <pre>
     * ISO 4217 currency code (if available) of the fiat currency.
     * </pre>
     *
     * <code>required string fiat_currency_code = 3;</code>
     * @return Whether the fiatCurrencyCode field is set.
     */
    boolean hasFiatCurrencyCode();
    /**
     * <pre>
     * ISO 4217 currency code (if available) of the fiat currency.
     * </pre>
     *
     * <code>required string fiat_currency_code = 3;</code>
     * @return The fiatCurrencyCode.
     */
    java.lang.String getFiatCurrencyCode();
    /**
     * <pre>
     * ISO 4217 currency code (if available) of the fiat currency.
     * </pre>
     *
     * <code>required string fiat_currency_code = 3;</code>
     * @return The bytes for fiatCurrencyCode.
     */
    com.google.protobuf.ByteString
        getFiatCurrencyCodeBytes();
  }
  /**
   * <pre>
   ** An exchange rate between Bitcoin and some fiat currency. 
   * </pre>
   *
   * Protobuf type {@code wallet.ExchangeRate}
   */
  public  static final class ExchangeRate extends
      com.google.protobuf.GeneratedMessageLite<
          ExchangeRate, ExchangeRate.Builder> implements
      // @@protoc_insertion_point(message_implements:wallet.ExchangeRate)
      ExchangeRateOrBuilder {
    private ExchangeRate() {
      fiatCurrencyCode_ = "";
    }
    private int bitField0_;
    public static final int COIN_VALUE_FIELD_NUMBER = 1;
    private long coinValue_;
    /**
     * <pre>
     * This much of satoshis (1E-8 fractions)
     * </pre>
     *
     * <code>required int64 coin_value = 1;</code>
     * @return Whether the coinValue field is set.
     */
    @java.lang.Override
    public boolean hasCoinValue() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This much of satoshis (1E-8 fractions)
     * </pre>
     *
     * <code>required int64 coin_value = 1;</code>
     * @return The coinValue.
     */
    @java.lang.Override
    public long getCoinValue() {
      return coinValue_;
    }
    /**
     * <pre>
     * This much of satoshis (1E-8 fractions)
     * </pre>
     *
     * <code>required int64 coin_value = 1;</code>
     * @param value The coinValue to set.
     */
    private void setCoinValue(long value) {
      bitField0_ |= 0x00000001;
      coinValue_ = value;
    }
    /**
     * <pre>
     * This much of satoshis (1E-8 fractions)
     * </pre>
     *
     * <code>required int64 coin_value = 1;</code>
     */
    private void clearCoinValue() {
      bitField0_ = (bitField0_ & ~0x00000001);
      coinValue_ = 0L;
    }

    public static final int FIAT_VALUE_FIELD_NUMBER = 2;
    private long fiatValue_;
    /**
     * <pre>
     * is worth this much of fiat (1E-4 fractions).
     * </pre>
     *
     * <code>required int64 fiat_value = 2;</code>
     * @return Whether the fiatValue field is set.
     */
    @java.lang.Override
    public boolean hasFiatValue() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * is worth this much of fiat (1E-4 fractions).
     * </pre>
     *
     * <code>required int64 fiat_value = 2;</code>
     * @return The fiatValue.
     */
    @java.lang.Override
    public long getFiatValue() {
      return fiatValue_;
    }
    /**
     * <pre>
     * is worth this much of fiat (1E-4 fractions).
     * </pre>
     *
     * <code>required int64 fiat_value = 2;</code>
     * @param value The fiatValue to set.
     */
    private void setFiatValue(long value) {
      bitField0_ |= 0x00000002;
      fiatValue_ = value;
    }
    /**
     * <pre>
     * is worth this much of fiat (1E-4 fractions).
     * </pre>
     *
     * <code>required int64 fiat_value = 2;</code>
     */
    private void clearFiatValue() {
      bitField0_ = (bitField0_ & ~0x00000002);
      fiatValue_ = 0L;
    }

    public static final int FIAT_CURRENCY_CODE_FIELD_NUMBER = 3;
    private java.lang.String fiatCurrencyCode_;
    /**
     * <pre>
     * ISO 4217 currency code (if available) of the fiat currency.
     * </pre>
     *
     * <code>required string fiat_currency_code = 3;</code>
     * @return Whether the fiatCurrencyCode field is set.
     */
    @java.lang.Override
    public boolean hasFiatCurrencyCode() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * ISO 4217 currency code (if available) of the fiat currency.
     * </pre>
     *
     * <code>required string fiat_currency_code = 3;</code>
     * @return The fiatCurrencyCode.
     */
    @java.lang.Override
    public java.lang.String getFiatCurrencyCode() {
      return fiatCurrencyCode_;
    }
    /**
     * <pre>
     * ISO 4217 currency code (if available) of the fiat currency.
     * </pre>
     *
     * <code>required string fiat_currency_code = 3;</code>
     * @return The bytes for fiatCurrencyCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFiatCurrencyCodeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(fiatCurrencyCode_);
    }
    /**
     * <pre>
     * ISO 4217 currency code (if available) of the fiat currency.
     * </pre>
     *
     * <code>required string fiat_currency_code = 3;</code>
     * @param value The fiatCurrencyCode to set.
     */
    private void setFiatCurrencyCode(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      fiatCurrencyCode_ = value;
    }
    /**
     * <pre>
     * ISO 4217 currency code (if available) of the fiat currency.
     * </pre>
     *
     * <code>required string fiat_currency_code = 3;</code>
     */
    private void clearFiatCurrencyCode() {
      bitField0_ = (bitField0_ & ~0x00000004);
      fiatCurrencyCode_ = getDefaultInstance().getFiatCurrencyCode();
    }
    /**
     * <pre>
     * ISO 4217 currency code (if available) of the fiat currency.
     * </pre>
     *
     * <code>required string fiat_currency_code = 3;</code>
     * @param value The bytes for fiatCurrencyCode to set.
     */
    private void setFiatCurrencyCodeBytes(
        com.google.protobuf.ByteString value) {
      fiatCurrencyCode_ = value.toStringUtf8();
      bitField0_ |= 0x00000004;
    }

    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoinj.wallet.Protos.ExchangeRate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoinj.wallet.Protos.ExchangeRate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     ** An exchange rate between Bitcoin and some fiat currency. 
     * </pre>
     *
     * Protobuf type {@code wallet.ExchangeRate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoinj.wallet.Protos.ExchangeRate, Builder> implements
        // @@protoc_insertion_point(builder_implements:wallet.ExchangeRate)
        org.bitcoinj.wallet.Protos.ExchangeRateOrBuilder {
      // Construct using org.bitcoinj.wallet.Protos.ExchangeRate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This much of satoshis (1E-8 fractions)
       * </pre>
       *
       * <code>required int64 coin_value = 1;</code>
       * @return Whether the coinValue field is set.
       */
      @java.lang.Override
      public boolean hasCoinValue() {
        return instance.hasCoinValue();
      }
      /**
       * <pre>
       * This much of satoshis (1E-8 fractions)
       * </pre>
       *
       * <code>required int64 coin_value = 1;</code>
       * @return The coinValue.
       */
      @java.lang.Override
      public long getCoinValue() {
        return instance.getCoinValue();
      }
      /**
       * <pre>
       * This much of satoshis (1E-8 fractions)
       * </pre>
       *
       * <code>required int64 coin_value = 1;</code>
       * @param value The coinValue to set.
       * @return This builder for chaining.
       */
      public Builder setCoinValue(long value) {
        copyOnWrite();
        instance.setCoinValue(value);
        return this;
      }
      /**
       * <pre>
       * This much of satoshis (1E-8 fractions)
       * </pre>
       *
       * <code>required int64 coin_value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCoinValue() {
        copyOnWrite();
        instance.clearCoinValue();
        return this;
      }

      /**
       * <pre>
       * is worth this much of fiat (1E-4 fractions).
       * </pre>
       *
       * <code>required int64 fiat_value = 2;</code>
       * @return Whether the fiatValue field is set.
       */
      @java.lang.Override
      public boolean hasFiatValue() {
        return instance.hasFiatValue();
      }
      /**
       * <pre>
       * is worth this much of fiat (1E-4 fractions).
       * </pre>
       *
       * <code>required int64 fiat_value = 2;</code>
       * @return The fiatValue.
       */
      @java.lang.Override
      public long getFiatValue() {
        return instance.getFiatValue();
      }
      /**
       * <pre>
       * is worth this much of fiat (1E-4 fractions).
       * </pre>
       *
       * <code>required int64 fiat_value = 2;</code>
       * @param value The fiatValue to set.
       * @return This builder for chaining.
       */
      public Builder setFiatValue(long value) {
        copyOnWrite();
        instance.setFiatValue(value);
        return this;
      }
      /**
       * <pre>
       * is worth this much of fiat (1E-4 fractions).
       * </pre>
       *
       * <code>required int64 fiat_value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFiatValue() {
        copyOnWrite();
        instance.clearFiatValue();
        return this;
      }

      /**
       * <pre>
       * ISO 4217 currency code (if available) of the fiat currency.
       * </pre>
       *
       * <code>required string fiat_currency_code = 3;</code>
       * @return Whether the fiatCurrencyCode field is set.
       */
      @java.lang.Override
      public boolean hasFiatCurrencyCode() {
        return instance.hasFiatCurrencyCode();
      }
      /**
       * <pre>
       * ISO 4217 currency code (if available) of the fiat currency.
       * </pre>
       *
       * <code>required string fiat_currency_code = 3;</code>
       * @return The fiatCurrencyCode.
       */
      @java.lang.Override
      public java.lang.String getFiatCurrencyCode() {
        return instance.getFiatCurrencyCode();
      }
      /**
       * <pre>
       * ISO 4217 currency code (if available) of the fiat currency.
       * </pre>
       *
       * <code>required string fiat_currency_code = 3;</code>
       * @return The bytes for fiatCurrencyCode.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFiatCurrencyCodeBytes() {
        return instance.getFiatCurrencyCodeBytes();
      }
      /**
       * <pre>
       * ISO 4217 currency code (if available) of the fiat currency.
       * </pre>
       *
       * <code>required string fiat_currency_code = 3;</code>
       * @param value The fiatCurrencyCode to set.
       * @return This builder for chaining.
       */
      public Builder setFiatCurrencyCode(
          java.lang.String value) {
        copyOnWrite();
        instance.setFiatCurrencyCode(value);
        return this;
      }
      /**
       * <pre>
       * ISO 4217 currency code (if available) of the fiat currency.
       * </pre>
       *
       * <code>required string fiat_currency_code = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFiatCurrencyCode() {
        copyOnWrite();
        instance.clearFiatCurrencyCode();
        return this;
      }
      /**
       * <pre>
       * ISO 4217 currency code (if available) of the fiat currency.
       * </pre>
       *
       * <code>required string fiat_currency_code = 3;</code>
       * @param value The bytes for fiatCurrencyCode to set.
       * @return This builder for chaining.
       */
      public Builder setFiatCurrencyCodeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFiatCurrencyCodeBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:wallet.ExchangeRate)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoinj.wallet.Protos.ExchangeRate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "coinValue_",
              "fiatValue_",
              "fiatCurrencyCode_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0003\u0001\u1502\u0000\u0002" +
                "\u1502\u0001\u0003\u1508\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoinj.wallet.Protos.ExchangeRate> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoinj.wallet.Protos.ExchangeRate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoinj.wallet.Protos.ExchangeRate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:wallet.ExchangeRate)
    private static final org.bitcoinj.wallet.Protos.ExchangeRate DEFAULT_INSTANCE;
    static {
      ExchangeRate defaultInstance = new ExchangeRate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ExchangeRate.class, defaultInstance);
    }

    public static org.bitcoinj.wallet.Protos.ExchangeRate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ExchangeRate> PARSER;

    public static com.google.protobuf.Parser<ExchangeRate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
